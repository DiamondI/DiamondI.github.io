<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>《海市蜃楼》观影记</title>
      <link href="/2023/03/05/%E6%B5%B7%E5%B8%82%E8%9C%83%E6%A5%BC%E8%A7%82%E5%BD%B1%E8%AE%B0/"/>
      <url>/2023/03/05/%E6%B5%B7%E5%B8%82%E8%9C%83%E6%A5%BC%E8%A7%82%E5%BD%B1%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1>《海市蜃楼》观影记</h1><h2 id="为何观看《海市蜃楼》">为何观看<a href="https://movie.douban.com/subject/30164448/?from=showing">《海市蜃楼》</a></h2><p>这是一部由西班牙导演<a href="https://movie.douban.com/celebrity/1323799/">奥里奥尔·保罗</a>执导的电影，此前他执导的<a href="https://movie.douban.com/subject/30384019/">《看不见的客人》</a>好评如潮。我因偶然间在知乎上刷到了一个问题：<a href="https://www.zhihu.com/question/317426232/answer/633768237">奥里奥尔·保罗导演的《海市蜃楼》比起前作《看不见的客人》有什么改变？<br></a>，而导演也是亲自对问题作出了<a href="https://www.zhihu.com/question/317426232/answer/633768237">解答</a>。当时的我并未仔细看解答，只是想着能拍出《看不见的客人》这样片子的导演，拍的《海市蜃楼》肯定也不会差，所以就决定要在这周末去看这部电影。某种程度上也算是慕名前去了。这篇观影记也因此诞生。</p><hr><p><strong>注：以下内容涉及剧透，请谨慎阅读！</strong></p><hr><span id="more"></span><h2 id="情节概述">情节概述</h2><p>电影中总共出现了三条时间线，后文中将按先后顺序，分别称其为<strong>时间线A</strong>，<strong>时间线B</strong>和<strong>时间线C</strong>。</p><h3 id="主要人物">主要人物</h3><table><thead><tr><th>姓名</th><th>身份</th></tr></thead><tbody><tr><td>尼克/莱拉警长</td><td>男主-时间线A中死于89年</td></tr><tr><td>维拉</td><td>女主-时间线A中搬进尼克故居的女护士</td></tr><tr><td>戴维</td><td>时间线A中女主的丈夫</td></tr><tr><td>安赫尔</td><td>尼克的邻居-杀妻凶手，在时间线A中坦白罪行</td></tr><tr><td>克拉拉</td><td>安赫尔的情人-属于安赫尔的杀妻同谋</td></tr><tr><td>希尔达魏斯</td><td>安赫尔的妻子-受害者</td></tr></tbody></table><h3 id="时间线A">时间线A</h3><p>在这条时间线中，89年雷雨交加的风暴之夜，尼克不小心目睹了安赫尔杀害自己妻子的场面，在被安赫尔追逐的过程中，尼克冲到马路上被疾驰而过的汽车撞倒，当场死去。</p><p>25年后，维拉和戴维（以及他们可爱的女儿）一家搬进了尼克曾经的房间里，在同样雷雨交加的风暴之夜，发现了尼克25年前的古老电视和古老摄像机。维拉意外发现能够通过这个电视和25年前的尼克对话，此时对往事既知的维拉，劝诫尼克不要因好奇心而去邻居家打探情况。尼克因此逃过一死，而因为过去的改变，维拉的生活也发生了变化，从此维拉进入了第二条时间线——时间线B。</p><h3 id="时间线B">时间线B</h3><p>在这条时间线中，维拉仍保有在时间线A中的记忆，但在这条时间线上的她与戴维并不是夫妻，她的身份也不再是护士，而是医生。在这条时间线中，女儿消失了、丈夫和身边的人也全都不再认识和相信自己。而只有探长莱拉仍然相信她，因为莱拉就是被她救下的89年本该死去的尼克。在时间线B中，过去的维拉过着完全不同的生活。在时间线B中，被救下的尼克，因为无人相信他的“未来的女人”的故事，所以他的证词没有被采纳，凶手安赫尔一直逍遥法外。尼克为了避免被当做是精神病，只好不再提及“未来的女人”的故事，而是不断默默寻找维拉。经过不懈的等待，他终于等到了维拉，并与她结为夫妻。</p><p>对维拉来说：</p><p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g1mt2k1y3fj30g10hqt9o.jpg" alt=""></p><p>维拉相当于是带着时间线A的过往记忆，却穿越到了时间线B中，她圈子里的人自然对她的认知不同。不仅如此，还会觉得他们认识的维拉与现在的维拉相去甚远，会开始怀疑维拉是否精神上遭受了打击。而只有同样经历过<strong>跨越时空的对话</strong>的尼克，会相信维拉的说辞。而此时的成年尼克——莱拉警长，早已与时间线B的维拉坠入爱河，尼克一点也不想维拉回到时间线A。</p><p>设定中，时间线A穿越到时间线B的维拉，一旦与他人有肢体上的接触，脑子里将会闪回时间线B中对该人的记忆。因此在时间线B的结尾，维拉其实已经认识到在这条时间线中，她与尼克结为了夫妻。但是放不下时间线A中自己女儿的维拉，还是想要创造出同样的条件，回到有女儿的时间线。维拉为了回到时间线A，甚至不惜以死相逼，逼尼克拿出穿越所必须的<strong>电视机与摄像机</strong>。于是在时间线B的结尾，成年尼克通过<strong>电视机</strong>与幼年尼克通话，叮嘱幼年尼克不许寻找“来自未来的女人”。在这样的条件下，时间线B里自杀身亡的维拉，又因为时间线的变动，来到了时间线C。</p><h3 id="时间线C">时间线C</h3><p>来到时间线C的维拉，发现安赫尔仍旧逍遥法外，于是知晓凶杀案始末的维拉，先挖出尸体，然后报警。结尾见到的警长也同样是尼克，只是尼克此时对维拉并没有印象，显然是时间线B中成年尼克的劝告奏效了（废话，不然哪来的时间线C）。</p><p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g1msv6u9bjj30oa0px774.jpg" alt=""></p><h3 id="关键节点总结">关键节点总结</h3><table><thead><tr><th>人物\时间线</th><th>A</th><th>B</th><th>C</th></tr></thead><tbody><tr><td>维拉</td><td>护士</td><td>医生</td><td>未知</td></tr><tr><td>尼克</td><td>死亡</td><td>存活</td><td>存活</td></tr><tr><td>维拉的女儿</td><td>存在</td><td>不存在</td><td>存在</td></tr><tr><td>安赫尔</td><td>杀妻凶手-25年前被抓</td><td>杀妻凶手-逍遥法外25年</td><td>杀妻凶手-逍遥法外25年</td></tr><tr><td>戴维-维拉的丈夫</td><td>出轨</td><td>出轨</td><td>出轨</td></tr></tbody></table><h2 id="感想">感想</h2><ul><li>不管在哪个时间线，杀人凶手还是那个杀人凶手，出轨的男人还是出轨=。=</li><li>母爱之深：时间线B的结局已经很美好了，和成年尼克——莱拉警长在一起的维拉在时间线B本来可以很幸福的，没有和出轨的丈夫戴维在一起，而是与帅气专一的尼克在一起，并且杀人凶手安赫尔又被绳之以法。不过唯一的美中不足是少了时间线A中可爱的女儿，舍不得女儿的维拉还是执意要离开时间线B，可见母爱之深。</li><li>维拉的自私？即便知晓了在时间线B中，自己已经与尼克结为夫妻，可是还是执意要转换时间线，甚至是想回到时间线A中。<ul><li>如果时间线并不平行，那么穿越将回到时间线A，意味着尼克将死，之前为救尼克而扰乱时间线毫无意义。</li><li>如果时间线平行，那么带着时间线A记忆的维拉，凭什么决定时间线B的维拉的生死？要知道，在时间线A记忆的维拉出现之前，成年尼克与时间线B的维拉可是过着相当幸福的生活。这样一来，自杀身亡的带着时间线A记忆的维拉倒是进入到时间线C逍遥自在了，时间线B的尼克可就独身一人忍受着孤独与痛苦了。</li></ul></li><li>看起来尼克才是本片中最惨的角色：时间线A中目睹杀人现场，逃离时被车撞死；时间线B中，本来与“来自未来的女人”相爱，但这份本可以长相厮守的爱，却被突然闯入的时间线A的维拉给破坏掉了；时间线C中的情况暂且未知，放下不表。</li></ul>]]></content>
      
      
      <categories>
          
          <category> movies </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Puzzle 1 - You Will All Confirm</title>
      <link href="/2023/03/05/you-will-all-confirm/"/>
      <url>/2023/03/05/you-will-all-confirm/</url>
      
        <content type="html"><![CDATA[<h1>Programming for the Puzzled</h1><p>这是MIT的一门公开课，讲师是Prof. Srini Devadas，课程的level是本科生。</p><span id="more"></span><p><strong>Prof. Srini Devadas</strong></p><p><img src="https://www.csail.mit.edu/sites/default/files/styles/headshot/public/images/migration/devadas.jpg?h=5636fc5d&amp;itok=EUGLSbU-" alt="Prof. Srini Devadas"></p><h2 id="Puzzle-1-You-Will-All-Conform">Puzzle 1: You Will All Conform</h2><h3 id="Puzzle-Description">Puzzle Description</h3><p><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-s095-programming-for-the-puzzled-january-iap-2018/puzzle-1-you-will-all-conform/MIT6_S095IAP18_Puzzle_1.pdf">You Will All Confirm(PDF)</a></p><p><strong>问题描述（用自己的话描述）</strong></p><p>有一个队列的人排队进入棒球比赛的赛场，他们都戴有棒球帽，有的人帽檐朝前（Forward-F），有的人帽檐朝后（Backward-B）。而看门人需要让他们的帽檐都朝同一个方向，才能放这些排队的人入场。看门人可以对队列里的人发出“第i个位置的人调整帽檐方向”以及“第i到第j个位置的人调整帽檐方向”的命令。问看门人最少需要发出多少个命令，能够使这些人帽檐方向一致呢？</p><p>显然，这个问题找的是连续的’F’或’B’所出现的最小次数。</p><h3 id="Natural-Algorithm">Natural Algorithm</h3><p>最自然的想法，就是遍历两遍，第一遍的时候找出所有连续的’F’并记录个数，第二遍找出所有连续的’B’并记录个数。两相比较，选择小的那个输出。</p><p>不过，稍加思索便会发现，其实用不着两次遍历，一次遍历就可以记录下这些信息。只需要在帽檐方向发生变化的时候增加连续的’F’或’B’的个数即可。</p><p><strong>Natural Algorithm - One Pass:</strong></p><pre><code class="language-python">def pleaseConform(caps):    #Initialization    start = 0    forward = 0    backward = 0    intervals = []    #Determine intervals where caps are on in the same direction    for i in range(1, len(caps)):        if caps[start] != caps[i]:            # each interval is a tuple with 3 elements (start, end, type)            intervals.append((start, i - 1, caps[start]))                        if caps[start] == 'F':                forward += 1            else:                backward += 1            start = i    #Need to add the last interval after for loop completes execution    intervals.append((start, len(caps) - 1, caps[start]))    if caps[start] == 'F':        forward += 1    else:        backward += 1 ##    print (intervals)##    print (forward, backward)    if forward &lt; backward:        flip = 'F'    else:        flip = 'B'    for t in intervals:        if t[2] == flip:            #Exercise: if t[0] == t[1] change the printing!            print ('People in positions', t[0],                   'through', t[1], 'flip your caps!')</code></pre><p>可是这样写有一个小问题，那就是每次记录次数的时候都是发生在帽檐朝向变化的时候。这样一来，当一次遍历结束时，最后一个连续的区间会被忽略掉。为了处理这个问题，上面的代码在遍历结束之后，显式地将最后一个区间考虑了进去。</p><hr><p>这样写似乎不够优雅，有什么办法能够把这个特殊处理去掉呢？</p><p>讲师Prof. Srini Devadas提出了一个非常优雅的方案：在代表排队的人的list之后添加一个’End’元素。这样一来，遍历到’End’元素的时候，不论最后一个区间是什么，它都会被考虑进来。</p><p><strong>Natural Algorithm - One Pass &amp; Optimization:</strong></p><pre><code class="language-python">def pleaseConformOpt(caps):    #Initialization    start = 0    forward = 0    backward = 0    intervals = []    caps = caps + ['END']    #Determine intervals where caps are on in the same direction    for i in range(1, len(caps)):        if caps[start] != caps[i]:            # each interval is a tuple with 3 elements (start, end, type)            intervals.append((start, i - 1, caps[start]))                        if caps[start] == 'F':                forward += 1            else:                backward += 1            start = i    if forward &lt; backward:        flip = 'F'    else:        flip = 'B'    for t in intervals:        if t[2] == flip:            #Exercise: if t[0] == t[1] change the printing!            print ('People in positions', t[0], 'through', t[1], 'flip your caps!')</code></pre><p>这么一来，就可以用最少的代码来处理边界情况了。</p><h3 id="Another-Optimization">Another Optimization</h3><p>课程讲到上面的代码的时候，我以为已经是最优的写法了。没想到讲师Prof. Srini Devadas又给出了一段只有<strong>8行</strong>的代码！</p><p><strong>Natural Algorithm - One Pass &amp; Another Optimization:</strong></p><pre><code class="language-python">def pleaseConformOnepass(caps):    caps = caps + [caps[0]]    for i in range(1, len(caps)):        if caps[i] != caps[i-1]:            if caps[i] != caps[0]:                print('People in positions', i, end='')            else:                print(' through', i-1, 'flip your caps!')</code></pre><p>这段代码将list中的第一个元素放在了末尾，并且最后输出的时候只输出了与list中第一个元素不同的元素，即：如果第一个元素是’F’，那么这段代码只输出’B’的区间；反之亦然。</p><p>初见时百思不得其解，为什么只要输出与第一个元素不同的元素就好了啊！！！这段代码怕不是有bug！！！一定是讲师写错了！！！在这样的念头驱动下，我不停地尝试找反例，希望能找到一个例子使得上面代码的结果不符合题目要求。然而我想了好久都没想到反例，这时我才开始尝试论证上述代码的正确性。</p><hr><p><strong>并不严谨的正确性论证：</strong></p><p>证明第一个元素的连续区间数大于等于另一个元素，更具体地，第一个元素的连续区间数或者等于另一个元素，或者等于另一个元素的连续区间数+1。</p><p>引理L：对于末尾的元素来说，无法增加它的区间数，而不增加另一种元素的区间数。</p><p>引理L的不严谨证明：不妨设末尾元素是’B’，那么要想增加’B’的区间数，必须先用’F’元素来将此区间断开，然后再继续添加元素’B’，而一旦这么做了，'F’的区间数就增加了1个。</p><p>不妨设第一个元素是’F’，此时连续的’F’的区间数为1，比连续的’B’的区间数大1。此时可以在后面添加若干个’B’，使得连续的’B’的区间数也为1，此时’F’和’B’的区间相等。此时末尾元素是’B’，根据引理L，这之后无法增加’B’的区间数而不增加’F’的区间数。因此无论如何，'F’的区间数要么等于’B’的区间数，要么比’B’的区间数大一。</p><hr><p>在想清楚这一点之后，才终于明白为什么用8行代码就可以解决这个问题。不过，若是出现的元素多于两个，该命题就不再成立，因此也无法再简单地用8行代码解决帽檐朝向问题了。</p>]]></content>
      
      
      <categories>
          
          <category> Misc </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Web beacon 初探</title>
      <link href="/2023/03/05/web_beacon/"/>
      <url>/2023/03/05/web_beacon/</url>
      
        <content type="html"><![CDATA[<h1>Web beacon 初探</h1><h2 id="缘由">缘由</h2><p>近来读过不少服务提供商的隐私政策了，基本上每个都提到了Web beacon这个名词，而且通常会和Cookie一并提及。</p><span id="more"></span><p>比如豆瓣的隐私政策：</p><blockquote><p>除 Cookie 外，我们还会在网站上使用<strong>网站信标</strong>和像素标签等其他同类技术。例如，我们向你发送的电子邮件可能含有链接至我们网站内容的点击URL。如果你点击该链接，我们则会跟踪此次点击，帮助我们了解你的产品或服务偏好并改善客户服务。网站信标通常是一种嵌入到网站或电子邮件中的透明图像。借助于电子邮件中的像素标签，我们能够获知电子邮件是否被打开。</p></blockquote><p>对于这个名词很陌生的我，便决定搞搞清楚它到底是什么东西。</p><h2 id="释义">释义</h2><p>Web beacon，中文称<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%A0%87/2050262?fr=aladdin">网络信标</a>，又称网页臭虫（Web bug），是可以暗藏在任何网页元素或邮件内的1像素大小的透明GIF或PNG图片，常用来收集目标电脑用户的上网习惯等数据，并将这些数据写入Cookie。</p><h2 id="实验">实验</h2><p>豆瓣的隐私政策中说，网络信标可以检测所发送的电子邮件是否被打开。那实现这个的原理是什么呢？</p><h3 id="原理">原理</h3><p>在邮件中嵌入<code>img</code>标签，并添加<code>src</code>属性，那么当该邮件被打开的时候，<code>src</code>的值——一个指定的url，将会被访问。由此，被访问的url，将会得知该邮件被打开过。</p><h3 id="步骤">步骤</h3><p><strong>首先</strong>打开一个terminal，运行如下命令：</p><pre><code class="language-shell">python -m SimpleHTTPServer 8000</code></pre><p>该命令的含义是用Python在8000端口号创建一个SimpleHTTPServer，可以通过<code>http://localhost:8000</code>访问。当被访问时，terminal上会打印一行log信息。</p><p><strong>之后</strong>，用自己的A邮箱发邮件给B邮箱，内容是：</p><pre><code class="language-html">&lt;img src=&quot;http://localhost:8000&quot; height=&quot;1&quot; width=&quot;1&quot; &gt;&lt;/img&gt;</code></pre><p>上面这个像素为1的代码即为网络信标。</p><p>【<em>注意：</em> 需要用HTML编辑模式才行，我实验的时候是使用的QQ邮箱，它可以使用HTML编辑模式】</p><p><strong>最后</strong>，B邮箱收到A邮箱发来的邮件，点开该邮件，发现terminal上新打印了一行log信息。重新点开该邮件，发现又新打印了一行log信息。这说明，网络信标确实可以检测邮件是否被打开。</p><h2 id="总结">总结</h2><p>上面的只是最基本的用法，但即便是如此，我也被这样的功能所震撼。更深入的用法，可以结合Cookie来使用，或者是用较新的Web技术——Beacon API（信标API）。</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>罗杰疑案——麻将的bug</title>
      <link href="/2023/03/05/roger/"/>
      <url>/2023/03/05/roger/</url>
      
        <content type="html"><![CDATA[<h1>罗杰疑案——麻将的bug</h1><p>在罗杰疑案中，有一段四个人在打麻将的过程中聊有关案件的八卦的情节。在这个情节中，医生Shepperd胡了一次天胡，而这次天胡却极可能是阿婆笔下的一个bug。</p><span id="more"></span><p><strong>天胡原文如下[^1]：</strong></p><blockquote><p>I did not answer for a moment. I was overwhelmed and intoxicated. I had read of there being such a thing as The Perferct Winning–going Mah Jong on one’s original hand. I had nerver hoped to hold the hand myself.</p><p>With suppressed triumph I laid my hand face upwards on the table.</p><p>‘As they say in Shanghai Club,’ I remarked–‘The Tinho–The Perfect Winning!’</p></blockquote><p>这里的<code>I</code>指的就是医生Shepperd，而这里的<code>The Tinho</code>和<code>The Perfect Wining</code>就是指”天胡“。</p><h2 id="何为天胡？">何为天胡？</h2><p>在麻将中，天胡指的是洗完牌之后，抓完起始牌，就发现已经胡牌了。这是一种只有庄家能胡的牌，因为只有庄家抓完起始牌后拥有14张牌，而其他人都只有13张牌，少了牌是不可能胡的。</p><p>简而言之，<strong>天胡</strong>要求胡牌的人必须是<strong>庄家</strong>！</p><p>那么，谁是庄家呢？</p><h2 id="庄家——East-Wind">庄家——East Wind</h2><p>在麻将中，如果庄家胡牌，那么将会继续坐庄；如果是非庄家的玩家胡牌了，那么就会轮到庄家的下家坐庄。在英语中，庄家被称作East Wind。这是因为在中国，庄家又被称作“东风”的关系。</p><p>下面是mahjong wiki里对连庄与轮庄的说明</p><blockquote><p>For the next hand, <strong>if the winner is not the dealer</strong>, rotate the dealer and seat winds counterclockwise. The South player of the first round becomes the new East, and the other players change seat winds accordingly. Shuffle the tiles, rebuild the wall, and start again! <strong>If the winner is the dealer</strong>, he continues to be the dealer and the dealer is not rotated.</p></blockquote><p><img src="http://mahjong.wikidot.com/local--files/index:winds/hand1.png" alt=""></p><blockquote><p>The player sitting at the star is East in the first hand.</p></blockquote><p><img src="http://mahjong.wikidot.com/local--files/index:winds/hand2.png" alt=""></p><blockquote><p>The player sitting at the star is now South</p></blockquote><p>在罗杰疑案的麻将情景中，有一个经常被提及的术语——East Wind：</p><p><strong>开局时，James，即医生坐庄[^1]：</strong></p><blockquote><p>‘Go on, James,’ said Caroline at last. ‘You’re East Wind.’</p></blockquote><p><strong>Caroline胡的第一局[^1]：</strong></p><blockquote><p>‘East Wind passes’, said Caroline. ‘I’ve got an idea of my own about Ralph Paton. Three Characters. But I’m keeping it to myself for the present.’</p></blockquote><p><strong>Miss Gannett胡的第一局[^1]：</strong></p><blockquote><p>East Wind passed， and we started a new hand in silence.</p></blockquote><p><strong>Miss Gannett胡的第二局[^1]：</strong></p><blockquote><p>East Wind passed, and we set to once more. Annie brought in the tea things. Caroline and Miss Gannett were both slightly ruffled as is often the case during one of these festive evenings.</p></blockquote><p>这里的East Wind passed字面上看是指东风吹了过去。既然东风是庄家的意思，那么这里的实际意思自然是指轮到下家坐庄了。也就是说，至少小说中的麻将是会轮流坐庄的。</p><p>另外值得一提的一点是，从原文中可以看出，他们是遵守上海俱乐部的麻将规则来打的。而上海麻将的坐庄规则和其他地方不太一样。</p><p><strong>上海麻将坐庄规则[^2]：</strong></p><blockquote><p><strong>庄家：</strong></p><p>第一局系统随机选择庄家。</p><p>谁胡牌下盘当庄家，若流局则上盘庄家下盘继续当庄家。</p><p>炮胡且一炮2响或3响，点炮者最近的一个胡牌者下家为下盘庄家。</p></blockquote><p>那么原文里看得出来这一点吗？其实是能看出来。从前面引用的原文的Caroline胡的第一局来看，她胡了之后换了庄家，虽然没有明说庄家是谁，但是显然是她出的第一张牌——“Three Character”，即三万。也就是说，她在胡牌之后就成为了庄家。虽说也有可能她恰好是医生的下家，但是一来文中看不出这一点，二来谁胡谁坐庄也与上海麻将的规则一致。因此一定程度上可以确定，他们的规则就是谁胡谁坐庄的上海规则。</p><h2 id="医生Shepperd是庄家吗？">医生Shepperd是庄家吗？</h2><p><strong>假如按照上海规则</strong></p><p>这时谁胡谁坐庄，显然上一次胡牌的人是Miss Gannett，庄家不可能是医生！</p><p><strong>假如按照其他地方规则</strong></p><p>如果小说中的麻将<strong>遵守连庄规则</strong>的话，那么医生也不可能是庄家！</p><p>在医生天胡之前，有这样一段描写[^1]：</p><blockquote><p>The situation became more strained. It was annoyance at Miss Gannett’s going Mah Jong for the third time running which prompted Caroline to say to me as we built a fresh wall:<br>‘You are too tiresome, James. You sit there like a dead-head, and say nothing at all’</p></blockquote><p>也就是说在医生Shepperd天胡之前，Miss Gannett已经连续胡了三次了。这意味着，医生Shepperd这时候不可能是庄家！</p><p>如果Miss Gannett胡牌的某一次轮到自己坐庄了，那么她就连庄了，不可能由医生来坐庄。只能考虑这三次都不是Miss Gannett坐庄，那么最可能的情况下是，Miss Gannett第一次胡牌的时候是在自己的下家，而医生恰好是她的上家；可是即便如此，Miss Gannett胡了三次牌之后，也是轮到自己坐庄而不是医生坐庄。</p><p>因此，这可能是阿婆笔下的一个<strong>bug</strong>！</p><p>不过，如果小说中的麻将并没有连庄机制的话，也就是说不管谁胡牌，都换下家做庄家的话，那么医生坐庄就合情合理了。因为文中明确写明开局的时候，医生是东风。后面医生的姐姐胡了一把，Miss Gannett连续胡了三局。四局结束之后，便恰好又轮到医生坐庄。</p><p>不过我还是倾向于这是阿婆笔下的一个bug，没有连庄机制的麻将，实在是难以想象！我觉得零食行人是不会答应的吧？</p><blockquote><p>Perhaps tinted with the West’s fascination with exotic oriental cultures, mahjong became all the rage in the 1920s in the West and was promoted as the crystallization of ancient Chinese wisdom. [^3]</p></blockquote><p>[^1]: The murder of roger ackroyd, HarperCollinsPublishers, Edition 2019 1</p><p>[^2]: 上海麻将百度百科，链接: <a href="https://baike.baidu.com/item/%E4%B8%8A%E6%B5%B7%E9%BA%BB%E5%B0%86/1688864">https://baike.baidu.com/item/上海麻将/1688864</a></p><p>[^3]: 陳熙遠. 從馬吊到馬將: 小玩意與大傳統交織的一段歷史因緣[J]. 2009.</p>]]></content>
      
      
      <categories>
          
          <category> Misc </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Priority Queue</title>
      <link href="/2023/03/05/priority_queue/"/>
      <url>/2023/03/05/priority_queue/</url>
      
        <content type="html"><![CDATA[<h1>Priority Queue</h1><p>I have introduced a data structure, priority queue, in <a href="https://diamondi.github.io/2018/09/12/215/">previous article</a> to solve question <em>Kth Largest Element in an Array</em>. And now let me introduce something about <code>priority_queue</code> in C++.</p><span id="more"></span><h2 id="Definition-span-id-123-span">Definition <span id=123></span></h2><p>A priority queue is a container adaptor that provides constant time lookup of the largest (by default) element, at the expense of logarithmic insertion and extraction. In C++, priority queue is a container defined in header <code>&lt;queue&gt;</code>. And here’s the definition:</p><pre><code class="language-cpp">template&lt;    class T,    class Container = std::vector&lt;T&gt;,    class Compare = std::less&lt;typename Container::value_type&gt;&gt; class priority_queue;</code></pre><p>From this definition, we shall see that it accepts three parameters: the first one is the type of the stored elements; the second one is the container used to store the elements; the last one is the definition of priority. Besides, <code>priority_quque</code> will be implemented with vector and use less standing for priority if not specified.</p><h2 id="Functions">Functions</h2><ul><li>top: accesses the top element, const time complexity</li><li>empty: checks whether the underlying container is empty</li><li>size: returns the number of elements</li><li>push: inserts element and sorts the underlying container</li><li>pop: removes the top element</li></ul><p>Click <a href="https://en.cppreference.com/w/cpp/container/priority_queue">here</a> for more information about priority_queue.</p>]]></content>
      
      
      <categories>
          
          <category> Data Structure </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Misc-10-otaku from hackme.inndy.tw</title>
      <link href="/2023/03/05/otaku/"/>
      <url>/2023/03/05/otaku/</url>
      
        <content type="html"><![CDATA[<h1>otaku</h1><p>这是一道来自<a href="https://hackme.inndy.tw">hackme.inndy.tw</a>的题目，Misc第十道。题目提示：<code>Some data was hidden in these images, please find the flag.</code></p><p>下载文件解压之后得到一个文件夹，下面有四张图片，其中三张是png格式的，一张是jpg格式的。看题目提示的意思，大概每张图会有一点信息。</p><span id="more"></span><h2 id="第一张图-Kuroyuki-Hime-png">第一张图-Kuroyuki_Hime.png</h2><p>这张图隐藏的信息最简单，直接strings一下就出来了，但是很可惜，得到的信息是<code>FAKE&#123;D1d y0u u5ed br41n bur5t?&#125;</code>，不是我们要找的flag。</p><h2 id="第二张图-Mikoto-Misaka-png">第二张图-Mikoto_Misaka.png</h2><p>这张图strings没有得到任何有意义的信息，于是考虑拖进stegsolve分析查看，然后在<code>Blue plane 0</code>看到了在这张图片里隐藏的信息：<code>F14G&#123;This is not you want&#125;</code>。很显然，这也不是我们要的flag，虽然已经长得很像了。</p><h2 id="第四张图-Yuuki-Asuna-jpg">第四张图-Yuuki_Asuna.jpg</h2><p>不要问为什么先说第四张图！问就是我做的过程中第三张图先没弄出来，先看的第四张图。这张图的话前面两个手段就不行了，想来也是，出题人不可能在两张图里用同样的隐藏手段嘛。然后就尝试binwalk分析一下，结果发现果然图片里还隐藏着一个压缩文件，提取之后解压，得到一个文本文件。上面写着：<code>OOPS&#123;You have the wrong file&#125;</code>。太遗憾了，也不是我们要找的flag。</p><h2 id="第三张图-Miku-Hatsune-png">第三张图-Miku_Hatsune.png</h2><p>这是一张初音的图，这两天看初音看得头都大了。前面三种手段已经使出我的浑身解数了，再让我拿新东西出来，我还真拿不出来了。这时候就想到去网上看看常见的ctf隐写题还有什么套路，找了许久发现有一种叫“盲水印”的隐写手段，经常会拿来出题。但是要解盲水印的话必须要得到原图才行啊，这里只给了一张图，图里也没有再隐藏压缩文件或是其他图片什么的。那这道题到底是在考什么呢？苦思冥想许久无果后，最终放弃挣扎，选择在telegram上询问该平台的搭建者。搭建者告诉了我一个令人震惊的事实——原图需要在网上搜索！当时我的表情就是这样的——Σ( ° △ °|||)︴。最后在网上找了很久，终于找到一张相同格式相同尺寸的看起来相同的图片。下载下来之后和这道题的初音图片用stegsolve分析，最后终于在减法操作里发现了本题的flag。<strong>万万没想到，原图要自己到网上找呀！</strong></p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode Weekly Contest 129</title>
      <link href="/2023/03/05/ltcd_contest_129/"/>
      <url>/2023/03/05/ltcd_contest_129/</url>
      
        <content type="html"><![CDATA[<h1>LeetCode Weekly Contest 129</h1><span id="more"></span><h2 id="1020-Partition-Array-Into-Three-Parts-With-Equal-Sum"><a href="https://leetcode.com/contest/weekly-contest-129/problems/partition-array-into-three-parts-with-equal-sum/">1020. Partition Array Into Three Parts With Equal Sum</a></h2><h2 id="Description">Description</h2><p>Given an array <code>A</code> of integers, return <code>true</code> if and only if we can partition the array into three non-empty parts with equal sums.</p><p>Formally, we can partition the array if we can find indexes <code>i+1 &lt; j</code> with <code>(A[0] + A[1] + ... + A[i] == A[i+1] + A[i+2] + ... + A[j-1] == A[j] + A[j-1] + ... + A[A.length - 1])</code></p><p><strong>Example 1:</strong></p><blockquote><p><strong>Input:</strong> [0,2,1,-6,6,-7,9,1,2,0,1]<br><br><strong>Output:</strong> true<br><br><strong>Explanation:</strong> 0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1<br></p></blockquote><p><strong>Example 2:</strong></p><blockquote><p><strong>Input:</strong> [0,2,1,-6,6,7,9,-1,2,0,1]<br><br><strong>Output:</strong> false<br></p></blockquote><p><strong>Example 3:</strong></p><blockquote><p><strong>Input</strong>: [3,3,6,5,-2,2,5,1,-9,4]<br><br><strong>Output:</strong> true<br><br><strong>Explanation:</strong> 3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4<br></p></blockquote><p><strong>Note:</strong></p><ol><li><code>3 &lt;= A.length &lt;= 50000</code></li><li><code>-10000 &lt;= A[i] &lt;= 10000</code></li></ol><h2 id="Idea">Idea</h2><p>The idea is quite intuitive. <strong>First,</strong> calculate the total sum of all the elements and  get <code>1/3</code> of sum, here denoted as <code>average</code>. Then go through the vector by one pass. During the for-loop, maintain two numbers denoted as <code>curSum</code> and <code>cnt</code>. If <code>curSum == average</code>, then <code>++cnt</code> and let <code>curSum</code> be <code>0</code>. If <code>cnt == 2</code>, then we can return <code>true</code>, otherwisr, we should return <code>false</code>.</p><h2 id="Solution">Solution</h2><pre><code class="language-cpp">class Solution &#123;public:    bool canThreePartsEqualSum(vector&lt;int&gt;&amp; A) &#123;        int sum = 0;        for (auto i: A) &#123;            sum += i;        &#125;        if (sum % 3) &#123;            return false;        &#125;        int average = sum / 3;        int curSum = 0;        int cnt = 0;        for (auto i: A) &#123;            curSum += i;            if (curSum == average) &#123;                cnt += 1;                curSum = 0;            &#125;            if (cnt == 2) &#123;                return true;            &#125;        &#125;        return false;    &#125;&#125;;</code></pre><h2 id="1022-Smallest-Integer-Divisible-by-K"><a href="https://leetcode.com/contest/weekly-contest-129/problems/smallest-integer-divisible-by-k/">1022. Smallest Integer Divisible by K</a></h2><h3 id="Description-2">Description</h3><p>Given a positive integer <code>K</code>, you need find the smallest positive integer <code>N</code> such that <code>N</code> is divisible by <code>K</code>, and <code>N</code> only contains the digit <strong>1</strong>.</p><p>Return the length of <code>N</code>.  If there is no such <code>N</code>, return <strong>-1</strong>.</p><p><strong>Example 1:</strong></p><blockquote><p><strong>Input:</strong> 1<br><br><strong>Output:</strong> 1<br><br><strong>Explanation:</strong> The smallest answer is N = 1, which has length 1.</p></blockquote><p><strong>Example 2:</strong></p><blockquote><p><strong>Input:</strong> 2<br><br><strong>Output:</strong> -1<br><br><strong>Explanation:</strong> There is no such positive integer N divisible by 2.</p></blockquote><p><strong>Example 3:</strong></p><blockquote><p><strong>Input:</strong> 3<br><br><strong>Output:</strong> 3<br><br><strong>Explanation:</strong> The smallest answer is N = 111, which has length 3.</p></blockquote><h3 id="Idea-2">Idea</h3><p>The basic idea is try the length one by one. However, the target number may be very long and the length can be even larger than <code>1000</code>. But, if you’re familiar with long division, then it’s quite easy to get the solution here. Take <code>K = 3</code> as an example:</p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1g1dzwcl9enj30c00e4mxs.jpg" width="200dip"/><p>We should try <code>1</code>, <code>11</code> and <code>111</code> one by one and finally know the answer is <code>111</code>. But here’s a trick that we don’t really need to calculate <code>111 % 3</code>. As in the progress of long division, we first try to use <code>1</code> to do the division and get the remainder <code>1</code>, and apparently <code>1</code> can’t be divided by <code>3</code> and then we need to try <code>11</code>. However, <code>11</code> can’t be divided by <code>3</code>, either. The reminader here is <code>2</code>. Then we need to consider <code>111</code>, do we need to do calculation of <code>111 % 3</code>? No, here we just follow the long division progress and find whether <code>2 * 10 + 1 = 21</code> can be divided by <code>3</code>.</p><h3 id="Solution-2">Solution</h3><pre><code class="language-cpp">class Solution &#123;public:    int smallestRepunitDivByK(int K) &#123;        int cur = 1, len = 1;        while (len &lt;= K &amp;&amp; cur % K) &#123;            cur = (cur % K) * 10 + 1;            ++len;        &#125;        return len &gt; K ? -1 : len;    &#125;&#125;;</code></pre><h2 id="1021-Best-Sightseeing-Pair"><a href="https://leetcode.com/contest/weekly-contest-129/problems/best-sightseeing-pair/">1021. Best Sightseeing Pair</a></h2><h3 id="Dscription">Dscription</h3><p>Given an array <code>A</code> of positive integers, <code>A[i]</code> represents the value of the <code>i</code>-th sightseeing spot, and two sightseeing spots <code>i</code> and <code>j</code> have distance <code>j - i</code> between them.</p><p>The score of a pair (<code>i &lt; j</code>) of sightseeing spots is <code>(A[i] + A[j] + i - j)</code> : the sum of the values of the sightseeing spots, <strong>minus</strong> the distance between them.</p><p>Return the maximum score of a pair of sightseeing spots.</p><p><strong>Example 1:</strong></p><blockquote><p><strong>Input:</strong> [8,1,5,2,6]<br><br><strong>Output:</strong> 11<br><br><strong>Explanation:</strong> i = 0, j = 2, A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11</p></blockquote><p><strong>Note:</strong></p><ol><li>2 &lt;= A.length &lt;= 50000</li><li>1 &lt;= A[i] &lt;= 1000</li></ol><h3 id="Idea-3">Idea</h3><p>Notice that our target <code>A[i] + A[j] + i - j</code> can be divided into two parts, <code>A[i] + i</code> and <code>A[j] - j</code>. We first calculate two vectors from the origin vector and one of them consists of <code>A[i] + i</code> denoted as <code>ai</code> in my code while another consists of <code>A[j] - [j]</code> named <code>aj</code> in my code. Take <strong>Example 1</strong>:</p><ul><li>ai: [8, 2, 7, 5, 10]</li><li>aj: [8, 0, 3, -1, 2]</li></ul><p>Then the task becomes to find the largest sum of <code>ai[i] + aj[j]</code> where <code>i &lt; j</code>. Any number less than <code>ai[i]</code> and occuring after it is no need to consider. Suppose we have an element <code>ai[k]</code> which is less than <code>ai[i]</code>, then for any <code>j</code>, <code>ai[k] + aj[j] &lt; ai[i] + aj[j]</code> and <code>ai[i]</code> can even combine with <code>aj[k]</code> while <code>ai[k]</code> can not. Thus, we only need to consider the situations where <code>ai[k] &gt; ai[i]</code>. And in such situation, we only need to compare the values <code>ai[i] + aj[m]</code> where <code>m</code> is in <code>(i, k]</code> and <code>ai[k] + aj[n]</code> where <code>n</code> is in <code>(k, q]</code> in which <code>q</code> is the index with <code>ai[q] &gt; ai[k]</code>. Finally, we would get the correct answer.</p><h3 id="Solution-3">Solution</h3><pre><code class="language-cpp">class Solution &#123;public:    int maxScoreSightseeingPair(vector&lt;int&gt;&amp; A) &#123;        int n = A.size();        vector&lt;int&gt; ai(n, 0), aj(n, 0);        for (int i = 0; i &lt; n; ++i) &#123;            ai[i] = A[i]+i;            aj[i] = A[i]-i;        &#125;                vector&lt;int&gt; cand(1, 0);        for (int i = 0; i &lt; n; ++i) &#123;            int pre = cand.back();            if (ai[i] &gt; ai[pre])                cand.push_back(i);        &#125;        cand.push_back(n);  // corner case                int res = INT_MIN;        for (int i = 0; i &lt; cand.size()-1; ++i) &#123;            for (int j = cand[i]+1; j &lt; n &amp;&amp; j &lt;= cand[i+1]; ++j) &#123;                res = max(res, ai[cand[i]]+aj[j]);            &#125;        &#125;        return res;    &#125;&#125;;</code></pre><h2 id="1023-Binary-String-With-Substrings-Representing-1-To-N"><a href="https://leetcode.com/contest/weekly-contest-129/problems/binary-string-with-substrings-representing-1-to-n/">1023. Binary String With Substrings Representing 1 To N</a></h2><h3 id="Description-3">Description</h3><p>Given a binary string <code>S</code> (a string consisting only of ‘0’ and '1’s) and a positive integer <code>N</code>, return true if and only if for every integer X from 1 to N, the binary representation of X is a substring of S.</p><p><strong>Example 1:</strong></p><blockquote><p><strong>Input:</strong> S = “0110”, N = 3<br><br><strong>Output:</strong> true<br></p></blockquote><p><strong>Example 2:</strong></p><blockquote><p><strong>Input:</strong> S = “0110”, N = 4<br><br><strong>Output:</strong> false</p></blockquote><p><strong>Note:</strong></p><ol><li><code>1 &lt;= S.length &lt;= 1000</code></li><li><code>1 &lt;= N &lt;= 10^9</code></li></ol><h3 id="Idea-4">Idea</h3><p>It surprises me that my brute-force solution using Python3 was accepted and it cost only 48ms. For more solutions, you can go to discussion <a href="https://leetcode.com/problems/binary-string-with-substrings-representing-1-to-n/discuss/?currentPage=1&amp;orderBy=most_posts&amp;query=">here</a>.</p><h3 id="Solution-4">Solution</h3><pre><code class="language-python">class Solution:    def queryString(self, S: str, N: int) -&gt; bool:        for i in range(1, N + 1):            x = bin(i)[2:]            if x not in S:                return False        return True</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何远程连接jupyter notebook</title>
      <link href="/2023/03/05/how_to_connect_remote_jupyter/"/>
      <url>/2023/03/05/how_to_connect_remote_jupyter/</url>
      
        <content type="html"><![CDATA[<h1>如何远程连接jupyter notebook</h1><span id="more"></span><h2 id="步骤">步骤</h2><ol><li>首先，保证远程的服务器和自己的本机上都安装有jupyter notebook。</li><li>在远程的服务器上，在终端上运行如下命令：</li></ol><pre><code>jupyter notebook --no-browser --port=8889# --port 指定一个自己喜欢的端口号</code></pre><ol start="3"><li>在自己的本机打开一个终端，并运行如下命令：</li></ol><pre><code>ssh -N -f -L localhost:8888:localhost:8889 username@your_remote_host_name -p 22# 第一个localhost:后面跟的是本机打开的端口，第二个localhost:后面跟的是远程服务器上打开的端口；# -p参数后面是服务器开放给ssh连接的端口号，若不指定的话，默认ssh端口号是22# 请修改username并确保那是自己真实的用户名，并且将your_remote_host_name修改为远程服务器的ip地址</code></pre><ol start="4"><li>运行上述命令后，可能会要求输入<code>ssh</code>连接服务器的密码，正常输入即可。</li><li>在本机上打开任意一个浏览器，键入<code>localhost:8888</code>（须与<code>ssh</code>命令中第一个<code>localhost</code>指定的端口对应）访问即可。</li></ol><h2 id="可能遇到的问题及我的解决方法">可能遇到的问题及我的解决方法</h2><ol><li>在本机打开之后，界面上要求输入验证，但是输入token之后仍然要求输入token，并且不停地循环。</li></ol><p>解决方案：运行jupyter notebook的时候设置无须密码登录：</p><pre><code>jupyter notebook --no-browser --port=8889 --NotebookApp.allow_password_change=False</code></pre>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>工藤新一，生日快乐！</title>
      <link href="/2023/03/05/happy_birthday/"/>
      <url>/2023/03/05/happy_birthday/</url>
      
        <content type="html"><![CDATA[<h1>工藤新一，生日快乐！</h1><p>今天是五四青年节，也是工藤新一的生日！所以我心血来潮，就有了下面这个巨丑的工藤新一😂</p><span id="more"></span><p><img src="https://raw.githubusercontent.com/DiamondI/image/master/%E5%B7%A5%E8%97%A4%E6%96%B0%E4%B8%80%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90.png" alt="工藤新一，生日快乐！"></p>]]></content>
      
      
      <categories>
          
          <category> Misc </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>fib recursion-memoization 装饰器实现</title>
      <link href="/2023/03/05/fib_memoization/"/>
      <url>/2023/03/05/fib_memoization/</url>
      
        <content type="html"><![CDATA[<h1>fib recursion-memoization 装饰器实现</h1><p>原题：<a href="https://leetcode.com/explore/learn/card/recursion-i/255/recursion-memoization/1661/">LeetCode explore: recursion-memoization</a></p><span id="more"></span><pre><code class="language-python">import functoolsclass Solution:    def fib_helper(fn):        cache = &#123;&#125;        @functools.wraps(fn)        def wrapper(*args, **kw):            n = args[1]            if n in cache:                return cache[n]            result = fn(*args, **kw)            cache[n] = result            return result        return wrapper        @fib_helper    def fib(self, N: int) -&gt; int:        if N &lt; 2:            return N        return self.fib(N - 1) + self.fib(N - 2)</code></pre><p><strong>注：</strong> 上述方法存在一个问题：cache是static的，即不是每次调用都更新。所以上述递归的实现类似于一种打表。</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>东极岛之旅</title>
      <link href="/2023/03/05/dongjidao/"/>
      <url>/2023/03/05/dongjidao/</url>
      
        <content type="html"><![CDATA[<h1><a href="https://baike.baidu.com/item/%E4%B8%9C%E6%9E%81%E5%B2%9B/3293952">东极岛</a>之旅</h1><p>清明节，同几个小伙伴一起到东极岛游玩。幸运的是清明无雨，我们也得以玩得尽兴。</p><p>东极岛实际上并不是一个正式的地理名称，也不是一个单独的岛屿，而是习惯上对浙江省舟山市普陀区东极镇所辖的所有岛屿的总称，其地理上的正式名称应该是“中街山列岛”。它是电影<a href="https://baike.baidu.com/item/%E5%90%8E%E4%BC%9A%E6%97%A0%E6%9C%9F/12804662">《后会无期》</a>的重要拍摄地点，也有“海上丽江”之称。</p><span id="more"></span><p>说来惭愧，《后会无期》这部电影，我是去电影院看的，然而在这次出行前对“东极岛”毫无印象。我大概是看了“假的电影”😂。</p><h2 id="东极镇"><a href="https://baike.baidu.com/item/%E4%B8%9C%E6%9E%81%E9%95%87">东极镇</a></h2><p>东极镇地处舟山群岛最东端，距沈家门渔港约45.5公里，位于东径122.4°，北纬30.1°之间。东至两兄弟屿接东海（12海里外为公海），南至黄大洋接洋鞍渔场，西至岱巨洋，北至嵊山渔场，陆域面积为11.7平方公里，海域面积约500平方公里，共有28个大小岛屿和108块礁组成。其中<strong>庙子湖</strong>、青浜、黄兴、<strong>东福山</strong>为四个住人岛，庙子湖岛陆域面积为2.638平方公里，青浜岛陆域面积为1.408平方公里，黄兴岛陆域面积为2.437平方公里，东福山陆域面积2.953平方公里，镇政府驻庙子湖岛，下辖一个社区一个村四个经济合作社。</p><h2 id="行程">行程</h2><p>由于时间紧张，这次只到了四个住人岛中的<strong>东福山</strong>和<strong>庙子湖</strong>：</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1g1w5r92pu1j319e06ujv5.jpg" alt="行程"></p><p><strong>注：</strong> 从流程图中会觉得庙子湖比东福山更远，实际上我们是先到了更远的东福山，然后在回程的时候才到庙子湖游玩。</p><p>不得不说，六个小时左右的大巴真的是叫人难受，万幸的是没有晕车到吐出来😝。而在船上的两小时也感觉晃得不行，不过总体来说，虽然乘坐交通工具坐到精疲力竭，但是也没有出行前想象中的那么可怕😁，一路上睡过来😪也还算平静。</p><h3 id="舟山">舟山</h3><p>第一天决定在舟山暂住一晚，晚上在住宿处附近的CBD里的一家叫“涌上外婆桥”的饭馆吃饭。似乎是同行的小伙伴在其他地方吃过觉得还不错，因此推荐了那里。味道确实挺不错的，基本上每上一道菜，那道菜便会被立马“扫荡”一空。或许也和坐了一天的大巴，真的饥肠辘辘有关吧！</p><p>吃过晚饭之后，我们一路走回住宿的地方，路程大概有3km左右。其间路过了一座很长的桥，这座桥的长度估摸着有1.5~2km。桥边有一个水库，不过下面水似乎都干了，大概海边的淡水资源确实紧缺？以及不知道为什么，大晚上的，桥上有一半的路上没有亮路灯。前一半有路灯的路上，几个人边聊天边散步，很是愉快；到了后半没有路灯的路上，空气中就突然增添了一些紧张的气息😨。嘛，不过几人抱团能出什么岔子呢？总不会走着走着少一个人吧Σ( ° △ °|||)︴</p><h3 id="东福山">东福山</h3><p>第二天坐船到东福山上的时候，已然是中午了。午饭是随意找了一个大排档解决的。点的菜也很随意——什么海鲜炒饭、海鲜炒年糕之类的，但是味道却蛮不错的呢！不过这家大排档有个很有趣的特点：每道菜都会放一些胡萝卜丝儿。不知道是不是最近胡萝卜降价了😯。</p><p>午饭后，我们稍作休息后便决定绕岛一圈，毕竟东福山陆域面积才2.95平方公里而已。在岛上随处可见的路牌上，可以看到很明显的三个景点：福如东海、象鼻峰和白云宫。因此我们决定看看这三个景点。</p><h4 id="福如东海">福如东海</h4><p>福如东海，多么玄学的名字！当历经千辛万苦抵达时，发现不过是一块石头上写着红色的“福”字罢了=。=</p><p>不过该景点附近风倒是很大，险些把我吹傻了😱。</p><h4 id="象鼻峰">象鼻峰</h4><p>福如东海到象鼻峰的路上有4km左右，本以为到海岛上是享受海滩的感觉的，没想到一路上都在爬山，还真有踏青的感觉。象鼻峰最高处估摸着离海面有80米高，有位胆子大的游客竟然敢在毫无防护装置的情况下爬上象鼻峰拍照。有恐高症的我，这样的事情连想都不敢想。若是稍有不慎，掉落下去，后果真是不堪设想。</p><h4 id="白云宫">白云宫</h4><p>经过两个多小时的爬山，我们已经很疲惫了，并不想看白云宫，只想下山回到住宿处。但离开象鼻峰后的我们，不愿意走回头路，于是按着路牌的指示，走了其他的路，寄希望于能够离开崎岖的山路重返平坦的大路。</p><p>但我们走的这条路，却同样也是通往白云宫的路。路上遇到一个岔路口，路口的路牌上面有之前游客写的“上不通”、“下不通”、“上下都不通”（真是调皮的游客啊，那到底哪个是对的呢？）。正当我们准备先向上走的时候，从上面下来了一对情侣，告诉我们上面没有路了（看来往下走是对的）。于是我们便和他们一起往下面走。</p><p>又经过几十分钟里在山路上的上上下下曲曲折折，我们终于重新回到了平坦的大路上，并且发现，大路与山路的交界处便是白云宫。总结起来，我们最终还是逆时针，绕着岛上的三个景点兜了一圈呢。</p><h4 id="下山观日落">下山观日落</h4><p>下山的途中，恰巧撞上日落时分，海边的日落景色真是美啊！</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1g1wh6xwhqaj31hc0psn2h.jpg" alt="日落景色1"></p><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1g1wh7hdhcbj30ps1hcgrn.jpg" alt="日落景色2"></p><h3 id="庙子湖">庙子湖</h3><p>第三天到达庙子湖的时候是上午。本来庙子湖有个博物馆的，本可以到那里去游览一番。但是不知道为什么，那天博物馆居然没有开门，真是遗憾啊！又因为岛上太阳太毒，我们前一天爬山又已经消磨了许多精力，我们实在不愿意再寻找景点了。最后我们找了一家咖啡酒馆，在那里点了几杯冷饮，坐在一起愉快地玩起了桌游。一直到中午回程的船出发才离开庙子湖。</p><h2 id="后记">后记</h2><p>这次旅行中给同行的一位帅气的小哥哥拍了两张照片，获得了小伙伴们的一致好评，以至于打趣说给我“加鸡腿”。老实说我不怎么拍照也不太会拍照，这次能拍出好看的照片，真真是因为运气好、风景美以及模特气质佳呀！</p><p>突然想起来，与我同行的五位小伙伴是同一个班的，而我都不是他们班的诶！真是奇妙的缘分😆！不过也经常串寝，不是同班胜似同班吧！</p><p>希望将来还能一直保持联系，保持这份如东极岛海水般澄澈的友谊！</p>]]></content>
      
      
      <categories>
          
          <category> 旅游 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Misc-9-big from hackme.inndy.tw</title>
      <link href="/2023/03/05/big/"/>
      <url>/2023/03/05/big/</url>
      
        <content type="html"><![CDATA[<h1>big</h1><p>这是一道来自<a href="https://hackme.inndy.tw">hackme.inndy.tw</a>的题目，Misc第九道。题目提示：<code>It's a big file, read the flag.</code></p><span id="more"></span><p>首先将文件下载下来，发现是一个只有1KB的大小的xz压缩文件。解压之后得到一个大小为2.5MB的，不知道是什么类型的文件。用Hex Fiend打开后发现这可能是在文件头上做了手脚，如下图所示：</p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fyl4uih3bpj30le0okn62.jpg" width="400px"/><p>可以看到可能是在xz的压缩文件的文件头上加了点什么东西。去搜索了一番之后发现xz的文件头应该是：</p><pre><code>FD 37 7A 58 5A 00 00</code></pre><p>对比上面的图片，发现就是在文件的开头加了<code>20</code>。用Hex Fiend这个十六进制的编辑器将其删除之后再保存，这下就得到了一个可以继续解压的xz压缩文件了。再解压之后就得到了一个大小为<strong>17GB</strong>（是的，你没看错，就是<strong>17GB</strong>这么大！）的txt文件，当时我的表情是这样的：Σ( ° △ °|||)︴这么大的文件，我手上没有哪个可视化的编辑器是可以正常打开它的。幸好Mac电脑的预览可以只看前面一点点（用head命令也可以起到类似的作用，不过没有预览直观），发现前面每一行的内容都是<code>THISisNOTFLAG&#123;&#125;</code>。然后想到要不从后面往前找试试看，就尝试用tail命令看了最后几行，结果flag就放在最后一行。拿到flag之后赶紧把这占空间的文本文件删了。</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Puzzle 2 - The Best Time To Party</title>
      <link href="/2023/03/05/best-time-to-party/"/>
      <url>/2023/03/05/best-time-to-party/</url>
      
        <content type="html"><![CDATA[<h1>Programming for Puzzled</h1><p>这是MIT的一门公开课，讲师是Prof. Srini Devadas，课程的level是本科生。</p><span id="more"></span><p><strong>Prof. Srini Devadas</strong></p><p><img src="https://www.csail.mit.edu/sites/default/files/styles/headshot/public/images/migration/devadas.jpg?h=5636fc5d&amp;itok=EUGLSbU-" alt="Prof. Srini Devadas"></p><h2 id="Puzzle-2-The-Best-Time-To-Party">Puzzle 2: The Best Time To Party</h2><h3 id="Puzzle-Description">Puzzle Description</h3><p><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-s095-programming-for-the-puzzled-january-iap-2018/puzzle-2-the-best-time-to-party/MIT6_S095IAP18_Puzzle_2.pdf">The Best Time to Party (PDF)</a></p><p><strong>问题描述（用自己的话描述）</strong></p><p>有一个聚会（party）将要举行，而聚会中有许多的小项目（celebrity）。现在给出了这些小项目的开始时间和结束时间（左闭右开），问何时参加聚会，可以同时看到最多的小项目？</p><p>题目假设开始时间和结束时间是以<code>[i, j)</code>，即左闭右开区间的形式出现，表示该小项目是<code>i-th</code>小时开始，<code>j-th</code>小时结束。并且假设参加时间也是整点。</p><p><strong>注：</strong> 左闭右开意味着，即便在一个小项目结束的时间点参加进去，也无法看到该项目了。</p><p>举例如下：</p><table><thead><tr><th>Celebrity</th><th>Comes</th><th>Goes</th></tr></thead><tbody><tr><td>Beyoncé</td><td>6</td><td>7</td></tr><tr><td>Taylor</td><td>7</td><td>9</td></tr><tr><td>Brad</td><td>10</td><td>11</td></tr><tr><td>Katy</td><td>10</td><td>12</td></tr><tr><td>Tom</td><td>8</td><td>10</td></tr><tr><td>Drake</td><td>9</td><td>11</td></tr><tr><td>Alicia</td><td>6</td><td>8</td></tr></tbody></table><h2 id="Naive-Algorithm">Naive Algorithm</h2><p>在课堂上，Devadas提问同学，同学提出了一个非常直觉也非常naive的算法：</p><blockquote><p>对每个小时都检查一遍，在该小时里同时举行的小项目有多少个，找出最多的那个即可。</p></blockquote><p>这个算法的正确性显然。效率呢？假设party开始时间是m，结束时间是n，celebrity数量是x，那么复杂度就是<code>O((n - m)x)</code>。若将<code>(n - m)</code>看作是常数，似乎是线性的，而且在时间间隔是小时的时候，将其看作常数确实未尝不可；但若时间间隔是分甚至是秒的时候，<code>(n - m)</code>便无法再简单地看作是常数了，复杂度也就不再是线性的了。</p><p>老师给出的示例代码如下：</p><pre><code class="language-python">#Programming for the Puzzled -- Srini Devadas#yThe Best Time to Party#Given a list of intervals when celebrities will be at the party#Output is the time that you want to go the party when the maximum number of#celebrities are still there.#Brute force algorithm implemented heresched = [(6, 8), (6, 12), (6, 7), (7, 8), (7, 10), (8, 9), (8, 10), (9, 12),            (9, 10), (10, 11), (10, 12), (11, 12)]def bestTimeToParty(schedule):    #Find start time and end time    start = schedule[0][0]    end = schedule[0][1]    for c in schedule:        start = min(c[0], start)        end = max(c[1], end)    #compute count of celebrities at each time    count = celebrityDensity(schedule, start, end)    ##    print (count)    maxcount = 0    #Range over times to find the time when the maximum celebrities are around.    for i in range(start, end + 1):        if count[i] &gt; maxcount:            maxcount = count[i]            time = i##    maxcount = max(count[start:end + 1])##    time = count.index(maxcount)    #Output the best time to party.    #Note that the \ means the statement continues on the next line.    print ('Best time to attend the party is at', time,\           'o\'clock', ':', maxcount, 'celebrities will be attending!')def celebrityDensity(sched, start, end):    #Initialize a list of length end + 1 to all 0's    count = [0] * (end + 1)    # i ranges over different times    for i in range(start, end + 1):        count[i] = 0        for c in sched:            #Check if celebrity c is around at time i            if c[0] &lt;= i and c[1] &gt; i:                count[i] += 1                    return count                bestTimeToParty(sched)</code></pre><p>代码中首先找到了schedule中所有celebrity中最早的开始时间和最晚的结束时间，即确定了遍历的时间范围。然后对每个小时都进行一次检查，最后得到最多项目同时进行的时间。</p><h3 id="Improve">Improve</h3><p>上面的算法依赖时间的粒度，因此一旦时间粒度变得更细了，上面的代码就需要修改。不仅如此，时间粒度变细之后也会使得计算量增加。</p><p>Devadas在课上又提出了新的思路：先将每个项目的开始时间和结束时间进行排序，然后对每个时间进行遍历，同时维护一个变量<code>count</code>来记录目前有多少个正在进行的项目。每当有项目开始的时候，就<code>count += 1</code>，而每当有项目结束的时候，就<code>count -= 1</code>。这样就可以找到最多同时有多少个项目在同时进行了。<strong>注意当有项目的开始时间和另一个项目的结束时间相同时，需要先考虑结束时间，这是因为左闭右开的性质。</strong></p><p>这样的话，假设小项目数有x个的话，那么时间复杂度由排序的复杂度决定，可以达到<code>O(xlogx)</code>的复杂度，显然比之前的算法要好。不仅如此，这个算法不依赖时间粒度，即便粒度达到了分或秒，都不需要更改大量的代码，只要确保时间仍然能够比较大小即可。</p><p>老师的示例代码如下：</p><pre><code class="language-python">#Programming for the Puzzled -- Srini Devadas#The Best Time to Party#Given a list of intervals when celebrities will be at the party#Output is the time that you want to go the party when the maximum number of#celebrities are still there.#Clever algorithm that will work with fractional timessched = [(6, 8), (6, 12), (6, 7), (7, 8), (7, 10), (8, 9), (8, 10), (9, 12),            (9, 10), (10, 11), (10, 12), (11, 12)]sched2 = [(6.0, 8.0), (6.5, 12.0), (6.5, 7.0), (7.0, 8.0), (7.5, 10.0), (8.0, 9.0),          (8.0, 10.0), (9.0, 12.0), (9.5, 10.0), (10.0, 11.0), (10.0, 12.0), (11.0, 12.0)]sched3 = [(6, 7), (7,9), (10, 11), (10, 12), (8, 10), (9, 11), (6, 8),          (9, 10), (11, 12), (11, 13), (11, 14)]def bestTimeToPartySmart(schedule):    #Convert schedule to list of start times and end times marked as such    times = []    for c in schedule:        times.append((c[0], 'start'))        times.append((c[1], 'end'))    #Sort the list of times.    #Each time is a start or end time of a celebrity sighting.    sortlist(times)##    print times    maxcount, time = chooseTime(times)    #Output best time to party    print ('Best time to attend the party is at', time,\           'o\'clock', ':', maxcount, 'celebrities will be attending!')    #Sort the elements of tlist in ascending order#Sorting is based on the value of the element tuple (both items!)#The original code had a bug in that it did not look at the second#item of each tuple and ensure that (x, 'end') of one interval#is sorted before (x, 'start') of a different tuple.def sortlist(tlist):    for index in range(len(tlist)-1):        ismall = index        for i in range(index, len(tlist)):            #Sort based on first item of tuple            if tlist[ismall][0] &gt; tlist[i][0] or \               (tlist[ismall][0] == tlist[i][0] and \                tlist[ismall][1] &gt; tlist[i][1]):                ismall = i        #Swap the positions of the elements at index and ismall indices        tlist[index], tlist[ismall] = tlist[ismall], tlist[index]        returndef chooseTime(times):        rcount = 0    maxcount = 0    time = 0        #Range through the times computing a running count of celebrities    for t in times:        if t[1] == 'start':            rcount = rcount + 1        elif t[1] == 'end':            rcount = rcount - 1        if rcount &gt; maxcount:            maxcount = rcount            time = t[0]                return maxcount, time##bestTimeToPartySmart(sched)bestTimeToPartySmart(sched2)bestTimeToPartySmart (sched3)</code></pre><p>奇怪的是，Devadas在这里并没有使用Python内置的sort函数，不仅如此，老师自己实现的sort是选择排序，效率是<code>O(x^2)</code>的。在这样的情况下，该算法与上面的算法孰优孰劣还不一定。但是老师一口咬定这个算法会更快，有点让我感到困惑🤔。</p><h3 id="Exercises">Exercises</h3><h4 id="Exercise-1">Exercise 1</h4><p><strong>Exercise 1:</strong> Suppose you are yourself a busy celebrity and don’t have complete freedom in choosing when you can go to the party. Add arguments to the procedure <strong>bestTimeToPartySmart</strong> and modify it so it determines the maximum number of celebrities you can see within a given time range between <code>ystart</code> and <code>yend</code>. As with celebrities the interval is <code>[ystart, yend)</code>,  so you are available at all times such that <code>ystart &lt;= t &lt; yend</code>.</p><p>其实就是问在给定的时间范围内，最多能同时看到几个celebrity。只需要在上面的代码里增加限制条件即可：</p><p><strong>老师给出的</strong><code>partysmart-exercise1.py</code><strong>代码</strong></p><pre><code class="language-python">#Programming for the Puzzled -- Srini Devadas#The Best Time to Party#Given a list of intervals when celebrities will be at the party#Output is the time that you want to go the party when the maximum number of#celebrities are still there.#Clever algorithm that will work with fractional timessched = [(6, 8), (6, 12), (6, 7), (7, 8), (7, 10), (8, 9), (8, 10), (9, 12),            (9, 10), (10, 11), (10, 12), (11, 12)]sched2 = [(6.0, 8.0), (6.5, 12.0), (6.5, 7.0), (7.0, 8.0), (7.5, 10.0), (8.0, 9.0),          (8.0, 10.0), (9.0, 12.0), (9.5, 10.0), (10.0, 11.0), (10.0, 12.0), (11.0, 12.0)]sched3 = [(6, 7), (7,9), (10, 11), (10, 12), (8, 10), (9, 11), (6, 8),          (9, 10), (11, 12), (11, 13), (11, 14)]#[ystart, yend) is the time that you can meet with the celebritiesdef bestTimeToPartySmart(schedule, ystart, yend):    #Convert schedule to list of start times and end times marked as such    times = []    for c in schedule:        times.append((c[0], 'start'))        times.append((c[1], 'end'))    #Sort the list of times.    #Each time is a start or end time of a celebrity sighting.    sortlist(times)##    print times    maxcount, time = chooseTimeConstrained(times, ystart, yend)    #Output best time to party    print ('Best time to attend the party is at', time,\           'o\'clock', ':', maxcount, 'celebrities will be attending!')    #Sort the elements of tlist in ascending order#Sorting is based on the value of the element tuple (both items!)#The original code had a bug in that it did not look at the second#item of each tuple and ensure that (x, 'end') of one interval#is sorted before (x, 'start') of a different tuple.def sortlist(tlist):    for index in range(len(tlist)-1):        ismall = index        for i in range(index, len(tlist)):            #Sort based on first item of tuple            if tlist[ismall][0] &gt; tlist[i][0] or \               (tlist[ismall][0] == tlist[i][0] and \                tlist[ismall][1] &gt; tlist[i][1]):                ismall = i        #Swap the positions of the elements at index and ismall indices        tlist[index], tlist[ismall] = tlist[ismall], tlist[index]        returndef chooseTimeConstrained(times, ystart, yend):    rcount = 0    maxcount = 0    time = 0        #Range through the times computing a running count of celebrities    for t in times:        if t[1] == 'start':            rcount = rcount + 1        elif t[1] == 'end':            rcount = rcount - 1        #Make sure that you are available during this time t[0]!        if rcount &gt; maxcount and t[0] &gt;= ystart and t[0] &lt; yend:            maxcount = rcount            time = t[0]    return maxcount, time#bestTimeToPartySmart(sched2, 7.0, 9.0)bestTimeToPartySmart(sched2, 10.0, 12.0)</code></pre><h4 id="Exercise-2">Exercise 2</h4><p><strong>Exercise 2:</strong> There is an alternative way of computing the best time to party that does not depend on the granularity of time. We choose each celebrity interval in turn, and determine how many other celebrity intervals contain the chosen celebrity’s start time. We pick the time to attend the party to be the start time of the celebrity whose start time is contained in the maximum number of other celebrity intervals. Code this algorithm and verify that it produces the same answer as the algorithm based on sorting.</p><p>这个练习提出了一个新的思路：检查每个celebrity的开始时间，找出哪一个celebrity的开始时间被最多的celebrity的时间间隔所包含，这就是所求的答案。</p><p>为什么这个思路是正确的呢？原因很简单，在基于排序的算法中，维护的最大数量只有在一个新的celebrity开始的时候才有可能会更新。所以题目所求的时间必然是某个celebrity的开始时间。</p><p>code就懒得写了😂，反正也不难。</p><h4 id="Exercise-3">Exercise 3</h4><p><strong>Puzzle Exercise 3:</strong> Imagine that there is a weight associated with each celebrity dependent on how much you like that particular celebrity. This can be represented in the schedule as a 3-tuple, e.g., <code>(6.0, 8.0, 3)</code>. The start time is 6.0, end time is 8.0 and the weight is 3. Modify the code so you find the time that the celebrities with maximum total weight are available. For example, given:</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g5dbixezi7j30fa0920tc.jpg" alt="Example"></p><p>We want to return the time corresponding to the right dotted line even though there are only two celebrities available at that time. This is because the weight associated with those two celebrities is 4, which is greater than the total weight of 3 associated with the three celebrities available during the first dotted line.</p><p>Here’s a more complex example:</p><pre><code>sched3 = [(6.0, 8.0, 2), (6.5, 12.0, 1), (6.5, 7.0, 2), (7.0, 8.0, 2), (7.5, 10.0, 3), (8.0, 9.0, 2),(8.0, 10.0, 1), (9.0, 12.0, 2), (9.5, 10.0, 4), (10.0, 11.0, 2), (10.0, 12.0, 3), (11.0, 12.0, 7)]</code></pre><p>For this schedule of celebrities, you want to attend at 11.0 o’clock where the weight of attending celebrities is 13 and maximum!</p><p>我的思路仍然是先将每个项目的开始时间和结束时间进行排序，同时记录下该项目的权重，然后有项目开始就增加相应的权重，结束就减少相应的权重。</p><p>代码如下：</p><pre><code class="language-python">import profilesched3 = [            (6.0, 8.0, 2), (6.5, 12.0, 1),            (6.5, 7.0, 2), (7.0, 8.0, 2),            (7.5, 10.0, 3), (8.0, 9.0, 2),            (8.0, 10.0, 1), (9.0, 12.0, 2),            (9.5, 10.0, 4), (10.0, 11.0, 2),            (10.0, 12.0, 3), (11.0, 12.0, 7)        ]def sortlist(times):    times.sort(key=lambda x: (x[0], x[1]))def bestTimeToParty(shed):    times = []    for i in shed:        times += [(i[0], 'start', i[-1])]        times += [(i[1], 'end', i[-1])]    sortlist(times)    count, maxcount = 0, 0    for i in times:        if i[1] == 'start':            count += i[-1]            if count &gt; maxcount:                maxcount = count                time = i[0]        else:            count -= i[-1]    print ('Best time to attend the party is at', time,\           'o\'clock', ':', maxcount, 'values in total!')profile.run('bestTimeToParty(sched3)')</code></pre><p>结果如下：</p><pre><code>Best time to attend the party is at 11.0 o'clock : 13 values in total!         32 function calls in 0.013 seconds   Ordered by: standard name   ncalls  tottime  percall  cumtime  percall filename:lineno(function)        1    0.000    0.000    0.000    0.000 :0(exec)        1    0.000    0.000    0.000    0.000 :0(print)        1    0.012    0.012    0.012    0.012 :0(setprofile)        1    0.000    0.000    0.000    0.000 :0(sort)        1    0.000    0.000    0.000    0.000 &lt;string&gt;:1(&lt;module&gt;)        1    0.000    0.000    0.000    0.000 ex3.py:12(sortlist)       24    0.000    0.000    0.000    0.000 ex3.py:13(&lt;lambda&gt;)        1    0.000    0.000    0.000    0.000 ex3.py:15(bestTimeToParty)        1    0.000    0.000    0.013    0.013 profile:0(bestTimeToParty(sched3))        0    0.000             0.000          profile:0(profiler)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Misc </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - 934. Shortest Bridge</title>
      <link href="/2023/03/05/934/"/>
      <url>/2023/03/05/934/</url>
      
        <content type="html"><![CDATA[<h1><a href="https://leetcode.com/problems/shortest-bridge/">934. Shortest Bridge</a></h1><h2 id="Description">Description</h2><p>In a given 2D binary array A, there are two islands.  (An island is a 4-directionally connected group of 1s not connected to any other 1s.)</p><span id="more"></span><p>Now, we may change 0s to 1s so as to connect the two islands together to form 1 island.</p><p>Return the smallest number of 0s that must be flipped.  (It is guaranteed that the answer is at least 1.)</p><p><strong>Example 1:</strong></p><blockquote><p><strong>Input:</strong> [[0,1],[1,0]]<br><br><strong>Output:</strong> 1</p></blockquote><p><strong>Example 2:</strong></p><blockquote><p><strong>Input:</strong> [[0,1,0],[0,0,0],[0,0,1]]<br><br><strong>Output:</strong> 2</p></blockquote><p><strong>Example 3:</strong></p><blockquote><p><strong>Input:</strong> [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]<br><br><strong>Output:</strong> 1</p></blockquote><p><strong>Note:</strong></p><ol><li><code>1 &lt;= A.length = A[0].length &lt;= 100</code></li><li><code>A[i][j] == 0 or A[i][j] == 1</code></li></ol><h2 id="Idea">Idea</h2><p>It’s a basic BFS problem. The solution is based on <em>votrubac</em>’s <a href="https://leetcode.com/problems/shortest-bridge/discuss/189293/C%2B%2B-BFS-Island-Expansion-%2B-UF-Bonus">answer</a>.</p><h2 id="Solution">Solution</h2><pre><code class="language-c++">class Solution &#123;public:    int paint(vector&lt;vector&lt;int&gt;&gt;&amp; A, int i, int j) &#123;        if (i &lt; 0 || j &lt; 0 || i == A.size() || j == A[0].size() || A[i][j] != 1) return 0;        A[i][j] = 2;        return 1 + paint(A, i + 1, j) + paint(A, i - 1, j) +               paint(A, i, j + 1) + paint(A, i, j - 1);    &#125;        bool expand(vector&lt;vector&lt;int&gt;&gt;&amp; A, int i, int j, int color) &#123;        if (i &lt; 0 || j &lt; 0 || i == A.size() || j == A[0].size()) return false;        if (A[i][j] == 0) A[i][j] = color + 1;        return A[i][j] == 1;    &#125;    int shortestBridge(vector&lt;vector&lt;int&gt;&gt;&amp; A) &#123;        for (int i = 0, found = 0; !found &amp;&amp; i &lt; A.size(); ++i) &#123;            for (int j = 0; !found &amp;&amp; j &lt; A[0].size(); ++j) found = paint(A, i, j);        &#125;                   for (int color = 2; ; ++color) &#123;            for (int i = 0; i &lt; A.size(); ++i) &#123;                for (int j = 0; j &lt; A[0].size(); ++j) &#123;                    if (A[i][j] == color &amp;&amp; ((expand(A, i - 1, j, color) ||                        expand(A, i, j - 1, color) ||                        expand(A, i + 1, j, color) ||                         expand(A, i, j + 1, color)))) &#123;                        return color - 2;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>94. Binary Tree Inorder Traversal</title>
      <link href="/2023/03/05/94/"/>
      <url>/2023/03/05/94/</url>
      
        <content type="html"><![CDATA[<h1><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/description/">94. Binary Tree Inorder Traversal</a></h1><h2 id="Description">Description</h2><p>Given a binary tree, return the <em>inorder</em> traversal of its nodes’ values.</p><span id="more"></span><p><strong>Example:</strong></p><pre><code>Input: [1,null,2,3]   1    \     2    /   3Output: [1,3,2]</code></pre><p><strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?</p><h2 id="Idea">Idea</h2><p>Stack</p><h2 id="Solution">Solution</h2><pre><code class="language-cpp">/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    // The order should be `left, right, root`    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt; res;        stack&lt;TreeNode*&gt; st;        TreeNode *p = root;        while (!st.empty() || p) &#123;            if (p) &#123;                st.push(p);                p = p-&gt;left;            &#125; else &#123;                TreeNode *node = st.top();                st.pop();                p = node-&gt;right;                // The order is just `left, right, root`                res.push_back(node-&gt;val);            &#125;        &#125;                return res;    &#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>300. Longest Increasing Subsequence</title>
      <link href="/2023/03/05/300/"/>
      <url>/2023/03/05/300/</url>
      
        <content type="html"><![CDATA[<h1><a href="https://leetcode.com/problems/longest-increasing-subsequence/description/">300. Longest Increasing Subsequence</a></h1><h2 id="Description">Description</h2><p>Given an unsorted array of integers, find the length of longest increasing subsequence. (For this question, it’s stricly increasing.)</p><span id="more"></span><p><strong>Example:</strong></p><blockquote><p><strong>Input:</strong> [10,9,2,5,3,7,101,18] <br><br><strong>Output:</strong> 4 <br><br><strong>Explanation:</strong> The longest increasing subsequence is [2,3,7,101], therefore the length is 4.</p></blockquote><p><strong>Note:</strong></p><ul><li>There may be more than one LIS combination, it is only necessary for you to return the length.</li><li>our algorithm should run in O(n<sup>2</sup>) complexity.</li></ul><p><strong>Follow up:</strong></p><p>Could you improve it to O(nlogn) time complexity?</p><h2 id="Idea">Idea</h2><p>DP.</p><h3 id="1-O-n-sup-2-sup">1. O(n<sup>2</sup>)</h3><p>Consider that <code>dp[i]</code> represents the longest increasing subsequence ending at <code>i</code>. First initiate the array with value <code>1</code>. Then for every number <code>j</code> less than <code>i</code>:</p><ul><li>If <code>dp[j] &lt; dp[i]</code>, <code>dp[i] = max(dp[i], dp[j] + 1)</code> (because <code>dp[i]</code> contributes to LIS)</li><li>otherwise, <code>dp[i] = dp[i]</code></li><li>Finally, the result is the maximum of array <code>dp</code></li></ul><p>The time complexity is O(n<sup>2</sup>)</p><h3 id="2-O-nlogn">2. O(nlogn)</h3><p>Consider we maintain a vector <code>dp</code> and <code>dp[i]</code> means the least value for LIS with length (i + 1).</p><ul><li>If current num is greater than any number in <code>dp</code>, push it to <code>dp</code></li><li>insert current num to the the <code>lower_bound</code> index.</li></ul><p>Notice that <code>dp</code> is actually ordered, an we can search num in O(logn) time. Then the total time complexity is O(nlogn). And the result is the size of <code>dp</code>.</p><h2 id="Solution">Solution</h2><pre><code class="language-cpp">// O(n^2)class Solution &#123;public:    int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;        if (nums.empty()) &#123;            return 0;        &#125;        vector&lt;int&gt; dp(nums.size(), 1);        for (int i = 1; i &lt; nums.size(); ++i) &#123;            for (int j = 0; j &lt; i; ++j) &#123;                if (nums[j] &lt; nums[i]) &#123;                    dp[i] = max(dp[i], dp[j] + 1);                &#125;            &#125;        &#125;        int res = 0;        for (int i = 0; i &lt; nums.size(); ++i) &#123;            res = max(res, dp[i]);        &#125;        return res;    &#125;&#125;;</code></pre><pre><code class="language-cpp">//O(nlogn)class Solution &#123;public:    int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;        if (nums.empty()) &#123;            return 0;        &#125;        vector&lt;int&gt; result;        for (size_t i = 0; i &lt; nums.size(); ++i) &#123;            auto it = lower_bound(result.begin(), result.end(), nums[i]);            if (it == result.end()) &#123;                result.push_back(nums[i]);            &#125; else &#123;                *it = nums[i];            &#125;        &#125;        return result.size();    &#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>284. Peeking Iterator</title>
      <link href="/2023/03/05/284/"/>
      <url>/2023/03/05/284/</url>
      
        <content type="html"><![CDATA[<h1><a href="https://leetcode-cn.com/problems/peeking-iterator/">LeetCode 284. Peeking Iterator</a></h1><h2 id="Description">Description</h2><p>Given an Iterator class interface with methods: <code>next()</code> and <code>hasNext()</code>, design and implement a PeekingIterator that support the <code>peek()</code> operation – it essentially <code>peek()</code> at the element that will be returned by the next call to <code>next()</code>.</p><span id="more"></span><p><strong>Example:</strong></p><blockquote><p>Assume that the iterator is initialized to the beginning of the list: <strong>[1,2,3]</strong>.<br>Call <strong>next()</strong> gets you 1, the first element in the list.<br>Now you call <strong>peek()</strong> and it returns 2, the next element. Calling <strong>next()</strong> after that still return 2.<br>You call <strong>next()</strong> the final time and it returns 3, the last element.<br>Calling <strong>hasNext()</strong> after that should return false.</p></blockquote><h2 id="Framework">Framework</h2><p>题目给出的框架如下，可以看出这个PeekingIterator继承了Iterator。</p><pre><code class="language-cpp">/* * Below is the interface for Iterator, which is already defined for you. * **DO NOT** modify the interface for Iterator. * *  class Iterator &#123; *struct Data; * Data* data; *Iterator(const vector&lt;int&gt;&amp; nums); * Iterator(const Iterator&amp; iter); * * // Returns the next element in the iteration. *int next(); * *// Returns true if the iteration has more elements. *bool hasNext() const; *&#125;; */class PeekingIterator : public Iterator &#123;public:PeekingIterator(const vector&lt;int&gt;&amp; nums) : Iterator(nums) &#123;    // Initialize any member here.    // **DO NOT** save a copy of nums and manipulate it directly.    // You should only use the Iterator interface methods.    &#125;    // Returns the next element in the iteration without advancing the iterator.int peek() &#123;&#125;// hasNext() and next() should behave the same as in the Iterator interface.// Override them if needed.int next() &#123;&#125;bool hasNext() const &#123;&#125;&#125;;</code></pre><h2 id="Idea">Idea</h2><p>根据题目的意思来看，hasNext和next的方法和父类一致，直接调用父类的方法即可，而peek方法则需要在取数的同时不往后迭代。那么一个可行的思路就是，用this指针构造一个父类的对象，再调用其next方法。</p><h2 id="Solution">Solution</h2><p>最终代码如下：</p><pre><code class="language-cpp">```cpp/* * Below is the interface for Iterator, which is already defined for you. * **DO NOT** modify the interface for Iterator. * *  class Iterator &#123; *struct Data; * Data* data; *Iterator(const vector&lt;int&gt;&amp; nums); * Iterator(const Iterator&amp; iter); * * // Returns the next element in the iteration. *int next(); * *// Returns true if the iteration has more elements. *bool hasNext() const; *&#125;; */class PeekingIterator : public Iterator &#123;public:PeekingIterator(const vector&lt;int&gt;&amp; nums) : Iterator(nums) &#123;    // Initialize any member here.    // **DO NOT** save a copy of nums and manipulate it directly.    // You should only use the Iterator interface methods.    &#125;    // Returns the next element in the iteration without advancing the iterator.int peek() &#123;        return Iterator(*this).next();&#125;// hasNext() and next() should behave the same as in the Iterator interface.// Override them if needed.int next() &#123;    return Iterator::next();&#125;bool hasNext() const &#123;    return Iterator::hasNext();&#125;&#125;;</code></pre><p>这道题并没有考察什么复杂的算法，而是考察了类的继承里的一些基本的概念，可以说是一道很有趣的题目了。</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>28. Implement strStr()</title>
      <link href="/2023/03/05/28/"/>
      <url>/2023/03/05/28/</url>
      
        <content type="html"><![CDATA[<h1><a href="https://leetcode.com/problems/implement-strstr/description/">28. Implement strStr()</a></h1><h2 id="Description">Description</h2><p>Implement <a href="http://www.cplusplus.com/reference/cstring/strstr/">strStr()</a>.</p><span id="more"></span><p><a href="http://www.cplusplus.com/reference/cstring/strstr/">http://www.cplusplus.com/reference/cstring/strstr/</a><br>Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</p><p><strong>Example 1:</strong></p><pre><code>Input: haystack = &quot;hello&quot;, needle = &quot;ll&quot;Output: 2</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;Output: -1</code></pre><p><strong>Clarification:</strong></p><p>What should we return when <strong>needle</strong> is an empty string? This is a great question to ask during an interview.</p><p>For the purpose of this problem, we will return 0 when <strong>needle</strong> is an empty string. This is consistent to C’s <a href="http://www.cplusplus.com/reference/cstring/strstr/">strstr()</a> and Java’s <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String)">indexOf()</a>.</p><h2 id="Idea">Idea</h2><p>KMP</p><h2 id="Solution">Solution</h2><pre><code class="language-c">void GetNext(char*, int*);int strStr(char* s, char* p) &#123;    int i = 0;int j = 0;int sLen = strlen(s);int pLen = strlen(p);    int *next = (int*)malloc(pLen * sizeof(int));    GetNext(p, next);while (i &lt; sLen &amp;&amp; j &lt; pLen)&#123;//①如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++    if (j == -1 || s[i] == p[j])&#123;i++;j++;&#125;else&#123;//②如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]    //next[j]即为j所对应的next值      j = next[j];&#125;&#125;if (j == pLen)return i - j;elsereturn -1;&#125;void GetNext(char* p,int* next)&#123;int pLen = strlen(p);next[0] = -1;int k = -1;int j = 0;while (j &lt; pLen - 1)&#123;//p[k]表示前缀，p[j]表示后缀if (k == -1 || p[j] == p[k]) &#123;++k;++j;next[j] = k;&#125;else &#123;k = next[k];&#125;&#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>215. Kth Largest Element in an Array</title>
      <link href="/2023/03/05/215/"/>
      <url>/2023/03/05/215/</url>
      
        <content type="html"><![CDATA[<h1><a href="https://leetcode.com/problems/kth-largest-element-in-an-array/description/">215. Kth Largest Element in an Array</a></h1><h2 id="Description">Description</h2><p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p><span id="more"></span><p><strong>Example 1:</strong></p><blockquote><p><strong>Input:</strong> [3,2,1,5,6,4] and k = 2 <br><br><strong>Output:</strong> 5</p></blockquote><p><strong>Example 2:</strong></p><blockquote><p><strong>Input:</strong> [3,2,3,1,2,4,5,5,6] and k = 4 <br><br><strong>Output:</strong> 4</p></blockquote><p>**Note: **</p><p>You may assume k is always valid, 1 ≤ k ≤ array’s length.</p><h2 id="Idea">Idea</h2><h3 id="Quick-Sort">Quick Sort</h3><p>We can partition the array like quick-sort. Use a pivot to partition the array to two parts, greater than pivot and less than pivot. If there are k-1 elements greater than pivot, then we have just found the k-th largest element. If there are less than k-1 elements greater than pivot, then we can continue to partition in right part. Otherwise, we continue to partition in left part. When we found there’re k-1 elements in the left part, we have finished our work.</p><h3 id="Priority-Queue">Priority Queue</h3><p>Just add all elements in the array to a priority_queue, then pop k-1 elements. And the top element is what we want.</p><h2 id="Solution">Solution</h2><pre><code class="language-cpp">// Quick Sortclass Solution &#123;public:    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;        int high = nums.size();        int low = 0;        while (low &lt; high) &#123;            int i = low, j = high - 1;            int pivot = nums[low];            while (i &lt;= j) &#123;                while (i &lt;= j &amp;&amp; nums[i] &gt;= pivot) &#123;                    i++;                &#125;                while (i &lt;= j &amp;&amp; nums[j] &lt; pivot) &#123;                    j--;                &#125;                if (i &lt; j) &#123;                    swap(nums[i++], nums[j--]);                &#125;            &#125;            swap(nums[low], nums[j]);            if (j == k - 1) &#123;                return pivot;            &#125; else if (j &lt; k - 1) &#123;                low = j + 1;            &#125; else &#123;                high = j;            &#125;        &#125;    &#125;&#125;;</code></pre><pre><code class="language-cpp">// Priority Queueclass Solution &#123;public:    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;        priority_queue&lt;int&gt; pq;                for (auto num : nums) &#123;            pq.push(num);        &#125;                while (k &gt; 1) &#123;            pq.pop();            k--;        &#125;                return pq.top();    &#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>160. Intersection of Two Linked Lists</title>
      <link href="/2023/03/05/160/"/>
      <url>/2023/03/05/160/</url>
      
        <content type="html"><![CDATA[<h1><a href="https://leetcode.com/problems/intersection-of-two-linked-lists/">160. Intersection of Two Linked Lists</a></h1><h2 id="Description">Description</h2><p>Write a program to find the node at which the intersection of two singly linked lists begins.</p><span id="more"></span><p>For example, the following two linked lists:</p><p><img src="https://assets.leetcode.com/uploads/2018/12/13/160_statement.png" alt=""><br>begin to intersect at node c1.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png" alt=""></p><pre><code>Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3Output: Reference of the node with value = 8Input Explanation: The intersected node's value is 8 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,0,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.</code></pre><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png" alt=""></p><pre><code>Input: intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1Output: Reference of the node with value = 2Input Explanation: The intersected node's value is 2 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [0,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.</code></pre><p><strong>Example 3:</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png" alt=""></p><pre><code>Input: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2Output: nullInput Explanation: From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.Explanation: The two lists do not intersect, so return null.</code></pre><p><strong>Notes:</strong></p><ul><li>If the two linked lists have no intersection at all, return null.</li><li>The linked lists must retain their original structure after the function returns.</li><li>You may assume there are no cycles anywhere in the entire linked structure.</li><li>Your code should preferably run in O(n) time and use only O(1) memory.</li></ul><h2 id="Idea">Idea</h2><p>Two Points:</p><ul><li>Maintain two pointers <em>pA</em> and <em>pB</em> initialized at the head of A and B, respectively. Then let them both traverse through the lists, one node at a time.</li><li>When <em>pA</em> reaches the end of a list, then redirect it to the head of B (yes, B, that’s right.); similarly when <em>pB</em> reaches the end of a list, redirect it the head of A.</li><li>If at any point <em>pA</em> meets <em>pB</em>, then <em>pA</em>/<em>pB</em> is the intersection node.</li></ul><h2 id="Solution">Solution</h2><pre><code class="language-cpp">/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;        if (!headA || !headB) &#123;            return NULL;        &#125;        int end = 0;        ListNode *pa = headA;        ListNode *pb = headB;        while (pa-&gt;next &amp;&amp; pb-&gt;next) &#123;            pa = pa-&gt;next;            pb = pb-&gt;next;        &#125;        ListNode *tmp, *temp;        if (pa-&gt;next) &#123;            tmp = pa;            temp = pb;            pa = headA;            pb = headB;            while (tmp-&gt;next) &#123;                tmp = tmp-&gt;next;                pa = pa-&gt;next;            &#125;            if (tmp != temp) &#123;                return NULL;            &#125;            while (pa != pb) &#123;                pa = pa-&gt;next;                pb = pb-&gt;next;            &#125;        &#125; else &#123;            tmp = pb;            temp = pa;            pa = headA;            pb = headB;            while (tmp-&gt;next) &#123;                tmp = tmp-&gt;next;                pb = pb-&gt;next;            &#125;            if (tmp != temp) &#123;                return NULL;            &#125;            while (pa != pb) &#123;                pa = pa-&gt;next;                pb = pb-&gt;next;            &#125;        &#125;                return pa;    &#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>155. Min Stack</title>
      <link href="/2023/03/05/155/"/>
      <url>/2023/03/05/155/</url>
      
        <content type="html"><![CDATA[<h1><a href="https://leetcode.com/problems/min-stack/">155. Min Stack</a></h1><h2 id="Description">Description</h2><p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p><ul><li>push(x) – Push element x onto stack.</li><li>pop() – Removes the element on top of the stack.</li><li>top() – Get the top element.</li><li>getMin() – Retrieve the minimum element in the stack.</li></ul><span id="more"></span><p><strong>Example:</strong></p><pre><code>MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin();   --&gt; Returns -3.minStack.pop();minStack.top();      --&gt; Returns 0.minStack.getMin();   --&gt; Returns -2.</code></pre><h2 id="Idea">Idea</h2><p>Use a stack to record the minimum.</p><h2 id="Solution">Solution</h2><pre><code class="language-cpp">class MinStack &#123;private:    stack&lt;int&gt; st;    stack&lt;int&gt; minimum;public:    /** initialize your data structure here. */    MinStack() &#123;        minimum.push(INT_MAX);    &#125;        void push(int x) &#123;        st.push(x);        if (x &lt;= minimum.top()) &#123;            minimum.push(x);        &#125;    &#125;        void pop() &#123;        if (st.empty()) &#123;            return;        &#125;        if (st.top() == minimum.top()) &#123;            minimum.pop();        &#125;        st.pop();    &#125;        int top() &#123;        if (st.empty()) &#123;            return -1;        &#125;        return st.top();    &#125;        int getMin() &#123;        if (st.empty()) &#123;            return -1;        &#125;        return minimum.top();    &#125;&#125;;/** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>154. Find Minimum in Rotated Sorted Array II</title>
      <link href="/2023/03/05/154/"/>
      <url>/2023/03/05/154/</url>
      
        <content type="html"><![CDATA[<h1><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/">154. Find Minimum in Rotated Sorted Array II</a></h1><h2 id="Description">Description</h2><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p><p>(i.e.,  <code>[0,1,2,4,5,6,7]</code> might become  <code>[4,5,6,7,0,1,2]</code>).</p><p>Find the minimum element.</p><span id="more"></span><p>The array may contain duplicates.</p><p><strong>Example 1:</strong></p><pre><code>Input: [1,3,5]Output: 1</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: [2,2,2,0,1]Output: 0</code></pre><p><strong>Note:</strong></p><ul><li>This is a follow up problem to Find Minimum in Rotated Sorted Array.</li><li>Would allow duplicates affect the run-time complexity? How and why?</li></ul><h2 id="Idea">Idea</h2><p>It’s a hard version of problem <a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/">153</a> with duplicates. Here we use three values, <code>left</code>, <code>mid</code> and <code>right</code>. If <code>left</code> is greater than <code>mid</code>, then the <em>minimum</em> locates in <code>(left, mid]</code> and thus we let <code>left</code> auto-increase by 1 and assign the value of <code>mid</code> to <code>right</code>. If <code>left</code> ≤ <code>mid</code> and <code>mid</code> &gt; <code>right</code>, certainly minimum locates in <code>(mid, right]</code>. Under the situation that <code>left</code> ≤ <code>mid</code> &lt;= <code>right</code>, if <code>left</code> &lt; <code>right</code>, then the minimum is <code>left</code> for that there’s only one pivot and if <code>left</code> == <code>right</code>, then we can’t determine whether minimum locates in <code>(left, mid]</code> or <code>(mid, right]</code>, thus simply let <code>right</code> auto-decrease by 1 and do the processes again.</p><h2 id="Solution">Solution</h2><pre><code class="language-cpp">class Solution &#123;public:    int findMin(vector&lt;int&gt;&amp; nums) &#123;        int length = nums.size();        if (length &lt; 0) &#123;            return -1;        &#125; else if (length == 1) &#123;            return nums[0];        &#125; else if (length == 2) &#123;            return min(nums[0], nums[1]);        &#125;                int left = 0, right = length - 1;        while (left &lt; right) &#123;            int mid = left + (right - left) / 2;            if (nums[left] &gt; nums[mid]) &#123;                left++;                right = mid;            &#125; else if (nums[mid] &gt; nums[right]) &#123;                left = mid + 1;            &#125; else &#123;                if (nums[left] &lt; nums[right]) &#123;                    return nums[left];                &#125; else &#123;                    right--;                &#125;            &#125;        &#125;        return nums[left];    &#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>153. Find Minimum in Rotated Sorted Array</title>
      <link href="/2023/03/05/153/"/>
      <url>/2023/03/05/153/</url>
      
        <content type="html"><![CDATA[<h1><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/">153. Find Minimum in Rotated Sorted Array</a></h1><h2 id="Description">Description</h2><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p><p>(i.e.,  <code>[0,1,2,4,5,6,7]</code> might become  <code>[4,5,6,7,0,1,2]</code>).</p><p>Find the minimum element.</p><span id="more"></span><p>You may assume no duplicate exists in the array.</p><p><strong>Example 1:</strong></p><pre><code>Input: [3,4,5,1,2] Output: 1</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: [4,5,6,7,0,1,2]Output: 0</code></pre><h2 id="Idea">Idea</h2><p>Just a simple dichotomy.</p><h2 id="Solution">Solution</h2><pre><code class="language-cpp">class Solution &#123;public:    int findMin(vector&lt;int&gt;&amp; nums) &#123;        int length = nums.size();        if (length &lt; 0) &#123;            return -1;        &#125; else if (length == 1) &#123;            return nums[0];        &#125; else if (length == 2) &#123;            return min(nums[0], nums[1]);        &#125;                int left = 0, right = length - 1, mid = (left + right) / 2;        while(left &lt; right) &#123;            if (nums[left] &lt;= nums[mid] &amp;&amp; nums[right] &lt; nums[mid]) &#123;                // means min locates at (mid, right]                left = mid + 1;                mid = ((mid + 1) + right) / 2;            &#125; else if (nums[right] &gt;= nums[mid]) &#123;                // means min locates at [left, mid]                right = mid;                mid = (left + mid) / 2;            &#125;        &#125;        return nums[left];    &#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>152. Maximum Product Subarray</title>
      <link href="/2023/03/05/152/"/>
      <url>/2023/03/05/152/</url>
      
        <content type="html"><![CDATA[<h1><a href="https://leetcode.com/problems/maximum-product-subarray/">152. Maximum Product Subarray</a></h1><h2 id="Description">Description</h2><p>Given an integer array <code>nums</code>, find the contiguous subarray within an array (containing at least one number) which has the largest product.</p><span id="more"></span><p><strong>Example 1:</strong></p><pre><code>Input: [2,3,-2,4]Output: 6Explanation: [2,3] has the largest product 6.</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: [-2,0,-1]Output: 0Explanation: The result cannot be 2, because [-2,-1] is not a subarray.</code></pre><h2 id="Idea">Idea</h2><p>Keep track the <code>max</code> and the <code>min</code>, and every time we meet a negative number, swap <code>max</code> and <code>min</code>. Finally, we will get the result.</p><h2 id="Solution">Solution</h2><pre><code class="language-c++">class Solution &#123;public:    int maxProduct(vector&lt;int&gt;&amp; nums) &#123;        int imax = nums[0], imin = nums[0], res = nums[0];        for (int i = 1; i &lt; (int) nums.size(); ++i) &#123;            int n = nums[i];            if (n &lt; 0) &#123;                swap(imax, imin);            &#125;            imax = max(n, imax * n);            imin = min(n, imin * n);            res = max(res, imax);        &#125;        return res;    &#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>150. Evaluate Reverse Polish Notation</title>
      <link href="/2023/03/05/150/"/>
      <url>/2023/03/05/150/</url>
      
        <content type="html"><![CDATA[<h1><a href="https://leetcode.com/problems/evaluate-reverse-polish-notation/description/">150. Evaluate Reverse Polish Notation</a></h1><h2 id="Description">Description</h2><p>Evaluate the value of an arithmetic expression in <a href="http://en.wikipedia.org/wiki/Reverse_Polish_notation">Reverse Polish Notation</a>(or <a href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F">逆波兰表达式</a>).</p><span id="more"></span><p>Valid operators are <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>. Each operand may be an integer or another expression.</p><p><strong>Note:</strong></p><ul><li>Division between two integers should truncate toward zero.</li><li>The given RPN expression is always valid. That means the expression would always evaluate to a result and there won’t be any divide by zero operation.</li></ul><p><strong>Example 1:</strong></p><blockquote><p><strong>Input:</strong> [“2”, “1”, “+”, “3”, “*”] <br><br><strong>Output:</strong> 9 <br><br><strong>Explanation:</strong> ((2 + 1) * 3) = 9</p></blockquote><p><strong>Example 2:</strong></p><blockquote><p><strong>Input:</strong> [“4”, “13”, “5”, “/”, “+”] <br><br><strong>Output:</strong> 6 <br><br><strong>Explanation:</strong> (4 + (13 / 5)) = 6</p></blockquote><p><strong>Example 3:</strong></p><blockquote><p><strong>Input:</strong> [“10”, “6”, “9”, “3”, “+”, “-11”, “*”, “/”, “*”, “17”, “+”, “5”, “+”] <br><br><strong>Output:</strong> 22 <br><br><strong>Explanation:</strong> <br><br>((10 * (6 / ((9 + 3) * -11))) + 17) + 5 <br><br>= ((10 * (6 / (12 * -11))) + 17) + 5 <br><br>= ((10 * (6 / -132)) + 17) + 5 <br><br>= ((10 * 0) + 17) + 5 <br><br>= (0 + 17) + 5 <br><br>= 17 + 5 <br><br>= 22</p></blockquote><h2 id="Idea">Idea</h2><p>Stack.</p><h2 id="Solution">Solution</h2><pre><code class="language-cpp">class Solution &#123;public:    int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;        stack&lt;int&gt; st;        for (const auto &amp;i : tokens) &#123;            if (i == &quot;+&quot;) &#123;                int a&#123;st.top()&#125;;                st.pop();                int b&#123;st.top()&#125;;                st.pop();                st.push(b + a);            &#125; else if (i == &quot;-&quot;) &#123;                int a&#123;st.top()&#125;;                st.pop();                int b&#123;st.top()&#125;;                st.pop();                st.push(b - a);            &#125; else if (i == &quot;*&quot;) &#123;                int a&#123;st.top()&#125;;                st.pop();                int b&#123;st.top()&#125;;                st.pop();                st.push(b * a);            &#125; else if (i == &quot;/&quot;) &#123;                int a&#123;st.top()&#125;;                st.pop();                int b&#123;st.top()&#125;;                st.pop();                st.push(b / a);            &#125; else &#123;                st.push(stoi(i));            &#125;        &#125;                return st.top();    &#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>149. Max Points on a Line</title>
      <link href="/2023/03/05/149/"/>
      <url>/2023/03/05/149/</url>
      
        <content type="html"><![CDATA[<h1><a href="https://leetcode.com/problems/max-points-on-a-line/">149. Max Points on a Line</a></h1><h2 id="Description">Description</h2><p>Given n points on a 2D plane, find the maximum number of points that lie on the same straight line.</p><span id="more"></span><p><strong>Example 1:</strong></p><pre><code>Input: [[1,1],[2,2],[3,3]]Output: 3Explanation:^||        o|     o|  o  +-------------&gt;0  1  2  3  4</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]Output: 4Explanation:^||  o|     o        o|        o|  o        o+-------------------&gt;0  1  2  3  4  5  6</code></pre><h2 id="Idea">Idea</h2><p>The code below is my simple solution for this problem using gcd algorithm to calculate the gradients.</p><h2 id="Solution">Solution</h2><pre><code class="language-Python"># Definition for a point.# class Point:#     def __init__(self, a=0, b=0):#         self.x = a#         self.y = bfrom math import gcdclass Solution:    def maxPoints(self, points):        &quot;&quot;&quot;        :type points: List[Point]        :rtype: int        &quot;&quot;&quot;        length = len(points)        if length &lt;= 2:            return length                tmp = [&#123;&#125; for i in range(length)]        res = 2        for i in range(length):            # count the number of duplicated points for point i            duplicate = 1            for j in range(length):                if i == j:                    continue                # count the gradient                # same point                if points[i].y == points[j].y and points[i].x == points[j].x:                    duplicate += 1                    continue                # vertical                elif points[i].x == points[j].x:                    gradient = (0, 0)                else:                    a = points[i].y - points[j].y                    b = points[i].x - points[j].x                    c = gcd(a, b)                    gradient = (a // c, b // c)                      if gradient not in tmp[i]:                    tmp[i][gradient] = 0                tmp[i][gradient] += 1            if duplicate == length:                res = duplicate                break            result = max(tmp[i].values()) + duplicate            res = max(res, result)                return res</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>145. Binary Tree Postorder Traversal</title>
      <link href="/2023/03/05/145/"/>
      <url>/2023/03/05/145/</url>
      
        <content type="html"><![CDATA[<h1><a href="https://leetcode.com/problems/binary-tree-postorder-traversal/description/">145. Binary Tree Postorder Traversal</a></h1><h2 id="Description">Description</h2><p>Given a binary tree, return the <em>postorder</em> traversal of its nodes’ values.</p><span id="more"></span><p><strong>Example:</strong></p><pre><code>Input: [1,null,2,3]   1    \     2    /   3Output: [3,2,1]</code></pre><p><strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?</p><h2 id="Idea">Idea</h2><p>Use stack to iteratively traverse the binary tree.</p><h2 id="Solution">Solution</h2><pre><code class="language-cpp">/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    // The order should be `left, right, root`    vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt; res;        stack&lt;TreeNode*&gt; st;        TreeNode *p = root;        while (!st.empty() || p) &#123;            if (p) &#123;                st.push(p);                // The order we push elements back to res is actually `root, right, left`                res.push_back(p-&gt;val);                p = p-&gt;right;            &#125; else &#123;                TreeNode *node = st.top();                st.pop();                p = node-&gt;left;            &#125;        &#125;                // We need to reverse res        reverse(res.begin(), res.end());                return res;    &#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>147. Insertion Sort List</title>
      <link href="/2023/03/05/147/"/>
      <url>/2023/03/05/147/</url>
      
        <content type="html"><![CDATA[<h1><a href="https://leetcode.com/problems/insertion-sort-list/description/">147. Insertion Sort List</a></h1><h2 id="Description">Description</h2><p>Sort a linked list using insertion sort.</p><span id="more"></span><p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif" alt=""></p><p>A graphical example of insertion sort. The partial sorted list (black) initially contains only the first element in the list.With each iteration one element (red) is removed from the input data and inserted in-place into the sorted list</p><p><strong>Algorithm of Insertion Sort:</strong></p><ol><li>Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list.</li><li>At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there.</li><li>It repeats until no input elements remain.</li></ol><p><strong>Example 1:</strong></p><blockquote><p>Input: 4-&gt;2-&gt;1-&gt;3 <br><br>Output: 1-&gt;2-&gt;3-&gt;4</p></blockquote><p><strong>Example 2:</strong></p><blockquote><p>Input: -1-&gt;5-&gt;3-&gt;4-&gt;0 <br><br>Output: -1-&gt;0-&gt;3-&gt;4-&gt;5</p></blockquote><h2 id="Idea">Idea</h2><p>Just use the Insertion Sort.</p><p>Or store the elements in vector and sort it first. But this is not inplace sort.</p><h2 id="Solution">Solution</h2><pre><code class="language-cpp">/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* insertionSortList(ListNode* head) &#123;        if (!head || !head-&gt;next) &#123;            return head;        &#125;        ListNode prehead(0);        prehead.next = head;                ListNode *p1 = head-&gt;next;        ListNode *preP1 = head;        ListNode *postP1 = p1-&gt;next;        while (p1) &#123;            ListNode *tmp = prehead.next;            ListNode *pre = &amp;prehead;            while (tmp != p1) &#123;                if (tmp-&gt;val &lt; p1-&gt;val) &#123;                    pre = tmp;                    tmp = tmp-&gt;next;                &#125; else &#123;                    // found the right place to insert p1                    p1-&gt;next = tmp;                    pre-&gt;next = p1;                    preP1-&gt;next = postP1;                    p1 = postP1;                    if (p1)                        postP1 = p1-&gt;next;                    break;                &#125;            &#125;            if (tmp == p1) &#123;                preP1 = p1;                p1 = p1-&gt;next;                if (p1)                    postP1 = p1-&gt;next;            &#125;        &#125;                return prehead.next;    &#125;&#125;;</code></pre><pre><code class="language-python"># Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def insertionSortList(self, head):        &quot;&quot;&quot;        :type head: ListNode        :rtype: ListNode        &quot;&quot;&quot;        if not head or not head.next:            return head        values = []        while head:            values.append(head.val)            head = head.next        values.sort()        res = ListNode(values[0])        p = res        for i in range(1, len(values)):            tmp = ListNode(values[i])            p.next = tmp;            p = p.next        return res</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>144. Binary Tree Preorder Traversal</title>
      <link href="/2023/03/05/144/"/>
      <url>/2023/03/05/144/</url>
      
        <content type="html"><![CDATA[<h1><a href="https://leetcode.com/problems/binary-tree-preorder-traversal/description/">144. Binary Tree Preorder Traversal</a></h1><h2 id="Description">Description</h2><p>Given a binary tree, return the <em>preorder</em> traversal of its nodes’ values.</p><span id="more"></span><p><strong>Example:</strong></p><pre><code>Input: [1,null,2,3]   1    \     2    /   3Output: [1,2,3]</code></pre><p><strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?</p><h2 id="Idea">Idea</h2><p>Stack.</p><h2 id="Solution">Solution</h2><pre><code class="language-cpp">/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    // The order should be `root, left, right`    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;        vector&lt;int&gt; res;        stack&lt;TreeNode*&gt; st;        TreeNode *p = root;        while (!st.empty() || p) &#123;            if (p) &#123;                st.push(p);                // The actual order is just root, left, right                res.push_back(p-&gt;val);                p = p-&gt;left;            &#125; else &#123;                TreeNode *node = st.top();                st.pop();                p = node-&gt;right;            &#125;        &#125;                return res;    &#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>143. Reorder List</title>
      <link href="/2023/03/05/143/"/>
      <url>/2023/03/05/143/</url>
      
        <content type="html"><![CDATA[<h1><a href="https://leetcode.com/problems/reorder-list/description/">143. Reorder List</a></h1><h2 id="Description">Description</h2><p>Given a singly linked list L: <em>L0→L1→…→Ln-1→Ln</em>,<br>reorder it to: <em>L0→Ln→L1→Ln-1→L2→Ln-2→…</em></p><span id="more"></span><p>You may <strong>not</strong> modify the values in the list’s nodes, only nodes itself may be changed.</p><p><strong>Example 1:</strong></p><blockquote><p>Given 1-&gt;2-&gt;3-&gt;4, reorder it to 1-&gt;4-&gt;2-&gt;3.</p></blockquote><p><strong>Example 2:</strong></p><blockquote><p>Given 1-&gt;2-&gt;3-&gt;4-&gt;5, reorder it to 1-&gt;5-&gt;2-&gt;4-&gt;3.</p></blockquote><h2 id="Idea">Idea</h2><p>At first, I had an idea that store the list in a vector first and then create a new list according to the rules. But it needs extra space and it’s not in place. Then I found another in place and constant space solution.</p><ol><li>cut the list at the middle node and make sure the left part’s size is the same as the right part’s or just has one more node.</li><li>reverse the right part list</li><li>merge the two llists</li></ol><h2 id="Solution">Solution</h2><pre><code class="language-cpp">/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    void reorderList(ListNode* head) &#123;        if (!head || !(head-&gt;next)) &#123;            return;        &#125;        ListNode *p1 = head, *p2 = head-&gt;next;                // find the middle node        while (p2 &amp;&amp; p2-&gt;next) &#123;            p1 = p1-&gt;next;            p2 = p2-&gt;next-&gt;next;        &#125;                // reverse the last middle        ListNode *a = p1-&gt;next;        while (a &amp;&amp; a-&gt;next) &#123;            ListNode *tmp = a-&gt;next;            a-&gt;next = tmp-&gt;next;            tmp-&gt;next = p1-&gt;next;            p1-&gt;next = tmp;        &#125;                ListNode *head2 = p1-&gt;next;        p1-&gt;next = NULL;                // merge the two lists        ListNode *p = head;        while (head2) &#123;            ListNode *tmp1 = p-&gt;next;            ListNode *tmp2 = head2-&gt;next;            p-&gt;next = head2;            head2-&gt;next = tmp1;            p = tmp1;            head2 = tmp2;        &#125;    &#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - 1187. Make Array Strictly Increasing</title>
      <link href="/2023/03/05/1187/"/>
      <url>/2023/03/05/1187/</url>
      
        <content type="html"><![CDATA[<h1><a href="https://leetcode.com/contest/weekly-contest-153/problems/make-array-strictly-increasing/">1187. Make Array Strictly Increasing</a></h1><h2 id="Description">Description</h2><p>Given two integer arrays <code>arr1</code> and <code>arr2</code>, return the minimum number of operations (possibly zero) needed to make <code>arr1</code> strictly increasing.</p><p>In one operation, you can choose two indices <code>0 &lt;= i &lt; arr1.length</code> and <code>0 &lt;= j &lt; arr2.length</code> and do the assignment <code>arr1[i] = arr2[j]</code>.</p><p>If there is no way to make <code>arr1</code> strictly increasing, return <code>-1</code>.</p><span id="more"></span><h2 id="Idea">Idea</h2><p><strong>Intuition:</strong></p><p>For any operation, we need to consider the smallest element in <code>arr2</code>. Thus, we sort the <code>arr2</code> first.</p><p><strong>Core idea:</strong></p><p>Run dfs with two branches:</p><ol><li>Keep the current element in <code>arr1</code></li><li>Add one replacement</li></ol><p>Finally return the minimum of these branches.</p><h2 id="Solution">Solution</h2><pre><code class="language-cpp">class Solution &#123;public:    const static int max_n = 2001;    int dp[max_n][max_n] = &#123;&#125;;    int dfs(vector&lt;int&gt;&amp; arr1, vector&lt;int&gt;&amp; arr2, int index1, int index2, int prev) &#123;        if (index1 &gt;= arr1.size()) &#123;            return 0;        &#125;        index2 = upper_bound(begin(arr2) + index2, end(arr2), prev) - begin(arr2);        int r1 = max_n, r2 = max_n;        if (!dp[index1][index2]) &#123;            if (index2 &lt; arr2.size()) &#123;                r2 = 1 + dfs(arr1, arr2, index1 + 1, index2, arr2[index2]);            &#125;            if (prev &lt; arr1[index1]) &#123;                r1 = dfs(arr1, arr2, index1 + 1, index2, arr1[index1]);            &#125;            dp[index1][index2] = min(r1, r2);        &#125;        return dp[index1][index2];    &#125;        int makeArrayIncreasing(vector&lt;int&gt;&amp; arr1, vector&lt;int&gt;&amp; arr) &#123;        std::set&lt;int&gt; aset(arr.begin(), arr.end());        vector&lt;int&gt; arr2(aset.begin(), aset.end());        int res = dfs(arr1, arr2, 0, 0, INT_MIN);        return res == max_n ? -1 : res;    &#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>115. Distinct Subsequences</title>
      <link href="/2023/03/05/115/"/>
      <url>/2023/03/05/115/</url>
      
        <content type="html"><![CDATA[<h1><a href="https://leetcode.com/problems/distinct-subsequences/description/">115. Distinct Subsequences</a></h1><h2 id="Description">Description</h2><p>Given a string <strong>S</strong> and a string <strong>T</strong>, count the number of distinct subsequences of <strong>S</strong> which equals <strong>T</strong>.</p><span id="more"></span><p>A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, <code>&quot;ACE&quot;</code> is a subsequence of <code>&quot;ABCDE&quot;</code> while <code>&quot;AEC&quot;</code> is not).</p><p><strong>Example 1:</strong></p><pre><code>Input: S = &quot;rabbbit&quot;, T = &quot;rabbit&quot;Output: 3Explanation:As shown below, there are 3 ways you can generate &quot;rabbit&quot; from S.(The caret symbol ^ means the chosen letters)rabbbit^^^^ ^^rabbbit^^ ^^^^rabbbit^^^ ^^^</code></pre><p><strong>Example 2:</strong></p><pre><code>Input: S = &quot;babgbag&quot;, T = &quot;bag&quot;Output: 5Explanation:As shown below, there are 5 ways you can generate &quot;bag&quot; from S.(The caret symbol ^ means the chosen letters)babgbag^^ ^babgbag^^    ^babgbag^    ^^babgbag  ^  ^^babgbag    ^^^</code></pre><h2 id="Idea">Idea</h2><p>Such problems about subsequence, can be solved by the idea of dynamic programming.</p><p>First, the length of <strong>T</strong> must be less than <strong>S</strong>, otherwise, the answer should be zero. Then, suppose the length of <strong>S</strong> is <code>m</code> and the length of <strong>T</strong> is <code>n</code> and we have a matrix named <code>dp</code> in which <code>dp[i][j]</code> means the answer for <strong>S[0, i - 1]</strong> and <strong>T[0, j - 1]</strong>. Subsequently, we have the following transfer equations:</p><ol><li>if <code>S[i - 1] != T[j - 1]</code>, <code>dp[i][j] = dp[i - 1][j]</code>.</li><li>else, <code>dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]</code>.</li></ol><p>After <code>mn</code> times iteration, we will get the answer and it’s just <code>dp[m][n]</code></p><h2 id="Solution">Solution</h2><pre><code class="language-cpp">class Solution &#123;public:    int numDistinct(string s, string t) &#123;        int m = s.length(), n = t.length();        if (n &gt; m) &#123;            return 0;        &#125;        vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0));        for (int i = 0; i &lt;= m; ++i) &#123;            dp[i][0] = 1;        &#125;                for (int i = 1; i &lt;= m; ++i) &#123;            for (int j = 1; j &lt;= n; ++j) &#123;                if (s[i - 1] != t[j - 1]) &#123;                    dp[i][j] = dp[i - 1][j];                &#125; else &#123;                    dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1];                &#125;            &#125;        &#125;                return dp[m][n];    &#125;&#125;;</code></pre><h3 id="Improve">Improve</h3><p>From the above codes, we can find that the space complexity is <code>O(mn)</code>. However, in every iteration, we only use two values, <code>dp[i - 1][j]</code> and <code>dp[i - 1][j - 1]</code>, in the <code>dp</code> matrix. And we can improve the space complexity to <code>O(n)</code>.</p><pre><code class="language-cpp">class Solution &#123;public:    int numDistinct(string s, string t) &#123;        int m = s.length(), n = t.length();        if (n &gt; m) &#123;            return 0;        &#125;        vector&lt;int&gt; dp(n + 1, 0);            dp[0] = 1;            for (int i = 1; i &lt;= m; ++i) &#123;            int pre = dp[0];            for (int j = 1; j &lt;= n; ++j) &#123;                int tmp = dp[j];                if (s[i - 1] == t[j - 1]) &#123;                    dp[j] = dp[j] + pre;                &#125;                pre = tmp;            &#125;         &#125;            return dp[n];    &#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/03/05/hello-world/"/>
      <url>/2023/03/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><pre><code class="language-bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><pre><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><pre><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><pre><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>

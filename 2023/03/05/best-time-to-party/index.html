<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>Puzzle 2 - The Best Time To Party</title><meta name="description" content="TODO"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="Programming for Puzzled
è¿™æ˜¯MITçš„ä¸€é—¨å…¬å¼€è¯¾ï¼Œè®²å¸ˆæ˜¯Prof. Srini Devadasï¼Œè¯¾ç¨‹çš„levelæ˜¯æœ¬ç§‘ç”Ÿã€‚

Prof. Srini Devadas

Puzzle 2: The Best Time To Party
Puzzle Description
The Best Time to Party (PDF)
é—®é¢˜æè¿°ï¼ˆç”¨è‡ªå·±çš„è¯æè¿°ï¼‰
æœ‰ä¸€ä¸ªèšä¼šï¼ˆpartyï¼‰å°†è¦ä¸¾è¡Œï¼Œè€Œèšä¼šä¸­æœ‰è®¸å¤šçš„å°é¡¹ç›®ï¼ˆcelebrityï¼‰ã€‚ç°åœ¨ç»™å‡ºäº†è¿™äº›å°é¡¹ç›®çš„å¼€å§‹æ—¶é—´å’Œç»“æŸæ—¶é—´ï¼ˆå·¦é—­å³å¼€ï¼‰ï¼Œé—®ä½•æ—¶å‚åŠ èšä¼šï¼Œå¯ä»¥åŒæ—¶çœ‹åˆ°æœ€å¤šçš„å°é¡¹ç›®ï¼Ÿ
é¢˜ç›®å‡è®¾å¼€å§‹æ—¶é—´å’Œç»“æŸæ—¶é—´æ˜¯ä»¥[i, j)ï¼Œå³å·¦é—­å³å¼€åŒºé—´çš„å½¢å¼å‡ºç°ï¼Œè¡¨ç¤ºè¯¥å°é¡¹ç›®æ˜¯i-thå°æ—¶å¼€å§‹ï¼Œj-thå°æ—¶ç»“æŸã€‚å¹¶ä¸”å‡è®¾å‚åŠ æ—¶é—´ä¹Ÿæ˜¯æ•´ç‚¹ã€‚
æ³¨ï¼š å·¦é—­.."><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="DiamondI's blog" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">DiamondI's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Puzzle 2 - The Best Time To Party</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">Programming for Puzzled</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Puzzle-2-The-Best-Time-To-Party"><span class="toc-text">Puzzle 2: The Best Time To Party</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Puzzle-Description"><span class="toc-text">Puzzle Description</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Naive-Algorithm"><span class="toc-text">Naive Algorithm</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Improve"><span class="toc-text">Improve</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exercises"><span class="toc-text">Exercises</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Exercise-1"><span class="toc-text">Exercise 1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Exercise-2"><span class="toc-text">Exercise 2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Exercise-3"><span class="toc-text">Exercise 3</span></a></li></ol></li></ol></li></ol></li></ol></div><div class="column is-9"><header class="my-4"></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">Puzzle 2 - The Best Time To Party</h1><time class="has-text-grey" datetime="2023-03-05T15:09:21.170Z">2023-03-05</time><article class="mt-2 post-content"><h1>Programming for Puzzled</h1>
<p>è¿™æ˜¯MITçš„ä¸€é—¨å…¬å¼€è¯¾ï¼Œè®²å¸ˆæ˜¯Prof. Srini Devadasï¼Œè¯¾ç¨‹çš„levelæ˜¯æœ¬ç§‘ç”Ÿã€‚</p>
<span id="more"></span>
<p><strong>Prof. Srini Devadas</strong></p>
<p><img src="https://www.csail.mit.edu/sites/default/files/styles/headshot/public/images/migration/devadas.jpg?h=5636fc5d&amp;itok=EUGLSbU-" alt="Prof. Srini Devadas"></p>
<h2 id="Puzzle-2-The-Best-Time-To-Party">Puzzle 2: The Best Time To Party</h2>
<h3 id="Puzzle-Description">Puzzle Description</h3>
<p><a target="_blank" rel="noopener" href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-s095-programming-for-the-puzzled-january-iap-2018/puzzle-2-the-best-time-to-party/MIT6_S095IAP18_Puzzle_2.pdf">The Best Time to Party (PDF)</a></p>
<p><strong>é—®é¢˜æè¿°ï¼ˆç”¨è‡ªå·±çš„è¯æè¿°ï¼‰</strong></p>
<p>æœ‰ä¸€ä¸ªèšä¼šï¼ˆpartyï¼‰å°†è¦ä¸¾è¡Œï¼Œè€Œèšä¼šä¸­æœ‰è®¸å¤šçš„å°é¡¹ç›®ï¼ˆcelebrityï¼‰ã€‚ç°åœ¨ç»™å‡ºäº†è¿™äº›å°é¡¹ç›®çš„å¼€å§‹æ—¶é—´å’Œç»“æŸæ—¶é—´ï¼ˆå·¦é—­å³å¼€ï¼‰ï¼Œé—®ä½•æ—¶å‚åŠ èšä¼šï¼Œå¯ä»¥åŒæ—¶çœ‹åˆ°æœ€å¤šçš„å°é¡¹ç›®ï¼Ÿ</p>
<p>é¢˜ç›®å‡è®¾å¼€å§‹æ—¶é—´å’Œç»“æŸæ—¶é—´æ˜¯ä»¥<code>[i, j)</code>ï¼Œå³å·¦é—­å³å¼€åŒºé—´çš„å½¢å¼å‡ºç°ï¼Œè¡¨ç¤ºè¯¥å°é¡¹ç›®æ˜¯<code>i-th</code>å°æ—¶å¼€å§‹ï¼Œ<code>j-th</code>å°æ—¶ç»“æŸã€‚å¹¶ä¸”å‡è®¾å‚åŠ æ—¶é—´ä¹Ÿæ˜¯æ•´ç‚¹ã€‚</p>
<p><strong>æ³¨ï¼š</strong> å·¦é—­å³å¼€æ„å‘³ç€ï¼Œå³ä¾¿åœ¨ä¸€ä¸ªå°é¡¹ç›®ç»“æŸçš„æ—¶é—´ç‚¹å‚åŠ è¿›å»ï¼Œä¹Ÿæ— æ³•çœ‹åˆ°è¯¥é¡¹ç›®äº†ã€‚</p>
<p>ä¸¾ä¾‹å¦‚ä¸‹ï¼š</p>
<table>
<thead>
<tr>
<th>Celebrity</th>
<th>Comes</th>
<th>Goes</th>
</tr>
</thead>
<tbody>
<tr>
<td>BeyoncÃ©</td>
<td>6</td>
<td>7</td>
</tr>
<tr>
<td>Taylor</td>
<td>7</td>
<td>9</td>
</tr>
<tr>
<td>Brad</td>
<td>10</td>
<td>11</td>
</tr>
<tr>
<td>Katy</td>
<td>10</td>
<td>12</td>
</tr>
<tr>
<td>Tom</td>
<td>8</td>
<td>10</td>
</tr>
<tr>
<td>Drake</td>
<td>9</td>
<td>11</td>
</tr>
<tr>
<td>Alicia</td>
<td>6</td>
<td>8</td>
</tr>
</tbody>
</table>
<h2 id="Naive-Algorithm">Naive Algorithm</h2>
<p>åœ¨è¯¾å ‚ä¸Šï¼ŒDevadasæé—®åŒå­¦ï¼ŒåŒå­¦æå‡ºäº†ä¸€ä¸ªéå¸¸ç›´è§‰ä¹Ÿéå¸¸naiveçš„ç®—æ³•ï¼š</p>
<blockquote>
<p>å¯¹æ¯ä¸ªå°æ—¶éƒ½æ£€æŸ¥ä¸€éï¼Œåœ¨è¯¥å°æ—¶é‡ŒåŒæ—¶ä¸¾è¡Œçš„å°é¡¹ç›®æœ‰å¤šå°‘ä¸ªï¼Œæ‰¾å‡ºæœ€å¤šçš„é‚£ä¸ªå³å¯ã€‚</p>
</blockquote>
<p>è¿™ä¸ªç®—æ³•çš„æ­£ç¡®æ€§æ˜¾ç„¶ã€‚æ•ˆç‡å‘¢ï¼Ÿå‡è®¾partyå¼€å§‹æ—¶é—´æ˜¯mï¼Œç»“æŸæ—¶é—´æ˜¯nï¼Œcelebrityæ•°é‡æ˜¯xï¼Œé‚£ä¹ˆå¤æ‚åº¦å°±æ˜¯<code>O((n - m)x)</code>ã€‚è‹¥å°†<code>(n - m)</code>çœ‹ä½œæ˜¯å¸¸æ•°ï¼Œä¼¼ä¹æ˜¯çº¿æ€§çš„ï¼Œè€Œä¸”åœ¨æ—¶é—´é—´éš”æ˜¯å°æ—¶çš„æ—¶å€™ï¼Œå°†å…¶çœ‹ä½œå¸¸æ•°ç¡®å®æœªå°ä¸å¯ï¼›ä½†è‹¥æ—¶é—´é—´éš”æ˜¯åˆ†ç”šè‡³æ˜¯ç§’çš„æ—¶å€™ï¼Œ<code>(n - m)</code>ä¾¿æ— æ³•å†ç®€å•åœ°çœ‹ä½œæ˜¯å¸¸æ•°äº†ï¼Œå¤æ‚åº¦ä¹Ÿå°±ä¸å†æ˜¯çº¿æ€§çš„äº†ã€‚</p>
<p>è€å¸ˆç»™å‡ºçš„ç¤ºä¾‹ä»£ç å¦‚ä¸‹ï¼š</p>
<pre><code class="language-python">#Programming for the Puzzled -- Srini Devadas
#yThe Best Time to Party
#Given a list of intervals when celebrities will be at the party
#Output is the time that you want to go the party when the maximum number of
#celebrities are still there.
#Brute force algorithm implemented here

sched = [(6, 8), (6, 12), (6, 7), (7, 8), (7, 10), (8, 9), (8, 10), (9, 12),
            (9, 10), (10, 11), (10, 12), (11, 12)]

def bestTimeToParty(schedule):
    #Find start time and end time
    start = schedule[0][0]
    end = schedule[0][1]
    for c in schedule:
        start = min(c[0], start)
        end = max(c[1], end)

    #compute count of celebrities at each time
    count = celebrityDensity(schedule, start, end)
    
##    print (count)
    maxcount = 0
    #Range over times to find the time when the maximum celebrities are around.
    for i in range(start, end + 1):
        if count[i] &gt; maxcount:
            maxcount = count[i]
            time = i

##    maxcount = max(count[start:end + 1])
##    time = count.index(maxcount)

    #Output the best time to party.
    #Note that the \ means the statement continues on the next line.
    print ('Best time to attend the party is at', time,\
           'o\'clock', ':', maxcount, 'celebrities will be attending!')


def celebrityDensity(sched, start, end):

    #Initialize a list of length end + 1 to all 0's
    count = [0] * (end + 1)
    # i ranges over different times
    for i in range(start, end + 1):
        count[i] = 0
        for c in sched:
            #Check if celebrity c is around at time i
            if c[0] &lt;= i and c[1] &gt; i:
                count[i] += 1
                
    return count
                

bestTimeToParty(sched)
</code></pre>
<p>ä»£ç ä¸­é¦–å…ˆæ‰¾åˆ°äº†scheduleä¸­æ‰€æœ‰celebrityä¸­æœ€æ—©çš„å¼€å§‹æ—¶é—´å’Œæœ€æ™šçš„ç»“æŸæ—¶é—´ï¼Œå³ç¡®å®šäº†éå†çš„æ—¶é—´èŒƒå›´ã€‚ç„¶åå¯¹æ¯ä¸ªå°æ—¶éƒ½è¿›è¡Œä¸€æ¬¡æ£€æŸ¥ï¼Œæœ€åå¾—åˆ°æœ€å¤šé¡¹ç›®åŒæ—¶è¿›è¡Œçš„æ—¶é—´ã€‚</p>
<h3 id="Improve">Improve</h3>
<p>ä¸Šé¢çš„ç®—æ³•ä¾èµ–æ—¶é—´çš„ç²’åº¦ï¼Œå› æ­¤ä¸€æ—¦æ—¶é—´ç²’åº¦å˜å¾—æ›´ç»†äº†ï¼Œä¸Šé¢çš„ä»£ç å°±éœ€è¦ä¿®æ”¹ã€‚ä¸ä»…å¦‚æ­¤ï¼Œæ—¶é—´ç²’åº¦å˜ç»†ä¹‹åä¹Ÿä¼šä½¿å¾—è®¡ç®—é‡å¢åŠ ã€‚</p>
<p>Devadasåœ¨è¯¾ä¸Šåˆæå‡ºäº†æ–°çš„æ€è·¯ï¼šå…ˆå°†æ¯ä¸ªé¡¹ç›®çš„å¼€å§‹æ—¶é—´å’Œç»“æŸæ—¶é—´è¿›è¡Œæ’åºï¼Œç„¶åå¯¹æ¯ä¸ªæ—¶é—´è¿›è¡Œéå†ï¼ŒåŒæ—¶ç»´æŠ¤ä¸€ä¸ªå˜é‡<code>count</code>æ¥è®°å½•ç›®å‰æœ‰å¤šå°‘ä¸ªæ­£åœ¨è¿›è¡Œçš„é¡¹ç›®ã€‚æ¯å½“æœ‰é¡¹ç›®å¼€å§‹çš„æ—¶å€™ï¼Œå°±<code>count += 1</code>ï¼Œè€Œæ¯å½“æœ‰é¡¹ç›®ç»“æŸçš„æ—¶å€™ï¼Œå°±<code>count -= 1</code>ã€‚è¿™æ ·å°±å¯ä»¥æ‰¾åˆ°æœ€å¤šåŒæ—¶æœ‰å¤šå°‘ä¸ªé¡¹ç›®åœ¨åŒæ—¶è¿›è¡Œäº†ã€‚<strong>æ³¨æ„å½“æœ‰é¡¹ç›®çš„å¼€å§‹æ—¶é—´å’Œå¦ä¸€ä¸ªé¡¹ç›®çš„ç»“æŸæ—¶é—´ç›¸åŒæ—¶ï¼Œéœ€è¦å…ˆè€ƒè™‘ç»“æŸæ—¶é—´ï¼Œè¿™æ˜¯å› ä¸ºå·¦é—­å³å¼€çš„æ€§è´¨ã€‚</strong></p>
<p>è¿™æ ·çš„è¯ï¼Œå‡è®¾å°é¡¹ç›®æ•°æœ‰xä¸ªçš„è¯ï¼Œé‚£ä¹ˆæ—¶é—´å¤æ‚åº¦ç”±æ’åºçš„å¤æ‚åº¦å†³å®šï¼Œå¯ä»¥è¾¾åˆ°<code>O(xlogx)</code>çš„å¤æ‚åº¦ï¼Œæ˜¾ç„¶æ¯”ä¹‹å‰çš„ç®—æ³•è¦å¥½ã€‚ä¸ä»…å¦‚æ­¤ï¼Œè¿™ä¸ªç®—æ³•ä¸ä¾èµ–æ—¶é—´ç²’åº¦ï¼Œå³ä¾¿ç²’åº¦è¾¾åˆ°äº†åˆ†æˆ–ç§’ï¼Œéƒ½ä¸éœ€è¦æ›´æ”¹å¤§é‡çš„ä»£ç ï¼Œåªè¦ç¡®ä¿æ—¶é—´ä»ç„¶èƒ½å¤Ÿæ¯”è¾ƒå¤§å°å³å¯ã€‚</p>
<p>è€å¸ˆçš„ç¤ºä¾‹ä»£ç å¦‚ä¸‹ï¼š</p>
<pre><code class="language-python">#Programming for the Puzzled -- Srini Devadas
#The Best Time to Party
#Given a list of intervals when celebrities will be at the party
#Output is the time that you want to go the party when the maximum number of
#celebrities are still there.
#Clever algorithm that will work with fractional times

sched = [(6, 8), (6, 12), (6, 7), (7, 8), (7, 10), (8, 9), (8, 10), (9, 12),
            (9, 10), (10, 11), (10, 12), (11, 12)]
sched2 = [(6.0, 8.0), (6.5, 12.0), (6.5, 7.0), (7.0, 8.0), (7.5, 10.0), (8.0, 9.0),
          (8.0, 10.0), (9.0, 12.0), (9.5, 10.0), (10.0, 11.0), (10.0, 12.0), (11.0, 12.0)]
sched3 = [(6, 7), (7,9), (10, 11), (10, 12), (8, 10), (9, 11), (6, 8),
          (9, 10), (11, 12), (11, 13), (11, 14)]


def bestTimeToPartySmart(schedule):
    #Convert schedule to list of start times and end times marked as such
    times = []
    for c in schedule:
        times.append((c[0], 'start'))
        times.append((c[1], 'end'))

    #Sort the list of times.
    #Each time is a start or end time of a celebrity sighting.
    sortlist(times)
##    print times

    maxcount, time = chooseTime(times)


    #Output best time to party
    print ('Best time to attend the party is at', time,\
           'o\'clock', ':', maxcount, 'celebrities will be attending!')
    

#Sort the elements of tlist in ascending order
#Sorting is based on the value of the element tuple (both items!)
#The original code had a bug in that it did not look at the second
#item of each tuple and ensure that (x, 'end') of one interval
#is sorted before (x, 'start') of a different tuple.
def sortlist(tlist):
    for index in range(len(tlist)-1):
        ismall = index
        for i in range(index, len(tlist)):
            #Sort based on first item of tuple
            if tlist[ismall][0] &gt; tlist[i][0] or \
               (tlist[ismall][0] == tlist[i][0] and \
                tlist[ismall][1] &gt; tlist[i][1]):
                ismall = i
        #Swap the positions of the elements at index and ismall indices
        tlist[index], tlist[ismall] = tlist[ismall], tlist[index]
    
    return


def chooseTime(times):
    
    rcount = 0
    maxcount = 0
    time = 0
    
    #Range through the times computing a running count of celebrities
    for t in times:
        if t[1] == 'start':
            rcount = rcount + 1
        elif t[1] == 'end':
            rcount = rcount - 1
        if rcount &gt; maxcount:
            maxcount = rcount
            time = t[0]
            
    return maxcount, time


##bestTimeToPartySmart(sched)
bestTimeToPartySmart(sched2)
bestTimeToPartySmart (sched3)
</code></pre>
<p>å¥‡æ€ªçš„æ˜¯ï¼ŒDevadasåœ¨è¿™é‡Œå¹¶æ²¡æœ‰ä½¿ç”¨Pythonå†…ç½®çš„sortå‡½æ•°ï¼Œä¸ä»…å¦‚æ­¤ï¼Œè€å¸ˆè‡ªå·±å®ç°çš„sortæ˜¯é€‰æ‹©æ’åºï¼Œæ•ˆç‡æ˜¯<code>O(x^2)</code>çš„ã€‚åœ¨è¿™æ ·çš„æƒ…å†µä¸‹ï¼Œè¯¥ç®—æ³•ä¸ä¸Šé¢çš„ç®—æ³•å­°ä¼˜å­°åŠ£è¿˜ä¸ä¸€å®šã€‚ä½†æ˜¯è€å¸ˆä¸€å£å’¬å®šè¿™ä¸ªç®—æ³•ä¼šæ›´å¿«ï¼Œæœ‰ç‚¹è®©æˆ‘æ„Ÿåˆ°å›°æƒ‘ğŸ¤”ã€‚</p>
<h3 id="Exercises">Exercises</h3>
<h4 id="Exercise-1">Exercise 1</h4>
<p><strong>Exercise 1:</strong> Suppose you are yourself a busy celebrity and donâ€™t have complete freedom in choosing when you can go to the party. Add arguments to the procedure <strong>bestTimeToPartySmart</strong> and modify it so it determines the maximum number of celebrities you can see within a given time range between <code>ystart</code> and <code>yend</code>. As with celebrities the interval is <code>[ystart, yend)</code>,  so you are available at all times such that <code>ystart &lt;= t &lt; yend</code>.</p>
<p>å…¶å®å°±æ˜¯é—®åœ¨ç»™å®šçš„æ—¶é—´èŒƒå›´å†…ï¼Œæœ€å¤šèƒ½åŒæ—¶çœ‹åˆ°å‡ ä¸ªcelebrityã€‚åªéœ€è¦åœ¨ä¸Šé¢çš„ä»£ç é‡Œå¢åŠ é™åˆ¶æ¡ä»¶å³å¯ï¼š</p>
<p><strong>è€å¸ˆç»™å‡ºçš„</strong><code>partysmart-exercise1.py</code><strong>ä»£ç </strong></p>
<pre><code class="language-python">#Programming for the Puzzled -- Srini Devadas
#The Best Time to Party
#Given a list of intervals when celebrities will be at the party
#Output is the time that you want to go the party when the maximum number of
#celebrities are still there.
#Clever algorithm that will work with fractional times

sched = [(6, 8), (6, 12), (6, 7), (7, 8), (7, 10), (8, 9), (8, 10), (9, 12),
            (9, 10), (10, 11), (10, 12), (11, 12)]
sched2 = [(6.0, 8.0), (6.5, 12.0), (6.5, 7.0), (7.0, 8.0), (7.5, 10.0), (8.0, 9.0),
          (8.0, 10.0), (9.0, 12.0), (9.5, 10.0), (10.0, 11.0), (10.0, 12.0), (11.0, 12.0)]
sched3 = [(6, 7), (7,9), (10, 11), (10, 12), (8, 10), (9, 11), (6, 8),
          (9, 10), (11, 12), (11, 13), (11, 14)]

#[ystart, yend) is the time that you can meet with the celebrities
def bestTimeToPartySmart(schedule, ystart, yend):
    #Convert schedule to list of start times and end times marked as such
    times = []
    for c in schedule:
        times.append((c[0], 'start'))
        times.append((c[1], 'end'))

    #Sort the list of times.
    #Each time is a start or end time of a celebrity sighting.
    sortlist(times)
##    print times

    maxcount, time = chooseTimeConstrained(times, ystart, yend)

    #Output best time to party
    print ('Best time to attend the party is at', time,\
           'o\'clock', ':', maxcount, 'celebrities will be attending!')
    

#Sort the elements of tlist in ascending order
#Sorting is based on the value of the element tuple (both items!)
#The original code had a bug in that it did not look at the second
#item of each tuple and ensure that (x, 'end') of one interval
#is sorted before (x, 'start') of a different tuple.
def sortlist(tlist):
    for index in range(len(tlist)-1):
        ismall = index
        for i in range(index, len(tlist)):
            #Sort based on first item of tuple
            if tlist[ismall][0] &gt; tlist[i][0] or \
               (tlist[ismall][0] == tlist[i][0] and \
                tlist[ismall][1] &gt; tlist[i][1]):
                ismall = i
        #Swap the positions of the elements at index and ismall indices
        tlist[index], tlist[ismall] = tlist[ismall], tlist[index]
    
    return


def chooseTimeConstrained(times, ystart, yend):

    rcount = 0
    maxcount = 0
    time = 0
    
    #Range through the times computing a running count of celebrities
    for t in times:
        if t[1] == 'start':
            rcount = rcount + 1
        elif t[1] == 'end':
            rcount = rcount - 1
        #Make sure that you are available during this time t[0]!
        if rcount &gt; maxcount and t[0] &gt;= ystart and t[0] &lt; yend:
            maxcount = rcount
            time = t[0]

    return maxcount, time


#bestTimeToPartySmart(sched2, 7.0, 9.0)
bestTimeToPartySmart(sched2, 10.0, 12.0)
</code></pre>
<h4 id="Exercise-2">Exercise 2</h4>
<p><strong>Exercise 2:</strong> There is an alternative way of computing the best time to party that does not depend on the granularity of time. We choose each celebrity interval in turn, and determine how many other celebrity intervals contain the chosen celebrityâ€™s start time. We pick the time to attend the party to be the start time of the celebrity whose start time is contained in the maximum number of other celebrity intervals. Code this algorithm and verify that it produces the same answer as the algorithm based on sorting.</p>
<p>è¿™ä¸ªç»ƒä¹ æå‡ºäº†ä¸€ä¸ªæ–°çš„æ€è·¯ï¼šæ£€æŸ¥æ¯ä¸ªcelebrityçš„å¼€å§‹æ—¶é—´ï¼Œæ‰¾å‡ºå“ªä¸€ä¸ªcelebrityçš„å¼€å§‹æ—¶é—´è¢«æœ€å¤šçš„celebrityçš„æ—¶é—´é—´éš”æ‰€åŒ…å«ï¼Œè¿™å°±æ˜¯æ‰€æ±‚çš„ç­”æ¡ˆã€‚</p>
<p>ä¸ºä»€ä¹ˆè¿™ä¸ªæ€è·¯æ˜¯æ­£ç¡®çš„å‘¢ï¼ŸåŸå› å¾ˆç®€å•ï¼Œåœ¨åŸºäºæ’åºçš„ç®—æ³•ä¸­ï¼Œç»´æŠ¤çš„æœ€å¤§æ•°é‡åªæœ‰åœ¨ä¸€ä¸ªæ–°çš„celebrityå¼€å§‹çš„æ—¶å€™æ‰æœ‰å¯èƒ½ä¼šæ›´æ–°ã€‚æ‰€ä»¥é¢˜ç›®æ‰€æ±‚çš„æ—¶é—´å¿…ç„¶æ˜¯æŸä¸ªcelebrityçš„å¼€å§‹æ—¶é—´ã€‚</p>
<p>codeå°±æ‡’å¾—å†™äº†ğŸ˜‚ï¼Œåæ­£ä¹Ÿä¸éš¾ã€‚</p>
<h4 id="Exercise-3">Exercise 3</h4>
<p><strong>Puzzle Exercise 3:</strong> Imagine that there is a weight associated with each celebrity dependent on how much you like that particular celebrity. This can be represented in the schedule as a 3-tuple, e.g., <code>(6.0, 8.0, 3)</code>. The start time is 6.0, end time is 8.0 and the weight is 3. Modify the code so you find the time that the celebrities with maximum total weight are available. For example, given:</p>
<p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g5dbixezi7j30fa0920tc.jpg" alt="Example"></p>
<p>We want to return the time corresponding to the right dotted line even though there are only two celebrities available at that time. This is because the weight associated with those two celebrities is 4, which is greater than the total weight of 3 associated with the three celebrities available during the first dotted line.</p>
<p>Hereâ€™s a more complex example:</p>
<pre><code>sched3 = [(6.0, 8.0, 2), (6.5, 12.0, 1), (6.5, 7.0, 2), (7.0, 8.0, 2), (7.5, 10.0, 3), (8.0, 9.0, 2),(8.0, 10.0, 1), (9.0, 12.0, 2), (9.5, 10.0, 4), (10.0, 11.0, 2), (10.0, 12.0, 3), (11.0, 12.0, 7)]
</code></pre>
<p>For this schedule of celebrities, you want to attend at 11.0 oâ€™clock where the weight of attending celebrities is 13 and maximum!</p>
<p>æˆ‘çš„æ€è·¯ä»ç„¶æ˜¯å…ˆå°†æ¯ä¸ªé¡¹ç›®çš„å¼€å§‹æ—¶é—´å’Œç»“æŸæ—¶é—´è¿›è¡Œæ’åºï¼ŒåŒæ—¶è®°å½•ä¸‹è¯¥é¡¹ç›®çš„æƒé‡ï¼Œç„¶åæœ‰é¡¹ç›®å¼€å§‹å°±å¢åŠ ç›¸åº”çš„æƒé‡ï¼Œç»“æŸå°±å‡å°‘ç›¸åº”çš„æƒé‡ã€‚</p>
<p>ä»£ç å¦‚ä¸‹ï¼š</p>
<pre><code class="language-python">import profile

sched3 = [
            (6.0, 8.0, 2), (6.5, 12.0, 1),
            (6.5, 7.0, 2), (7.0, 8.0, 2),
            (7.5, 10.0, 3), (8.0, 9.0, 2),
            (8.0, 10.0, 1), (9.0, 12.0, 2),
            (9.5, 10.0, 4), (10.0, 11.0, 2),
            (10.0, 12.0, 3), (11.0, 12.0, 7)
        ]

def sortlist(times):
    times.sort(key=lambda x: (x[0], x[1]))

def bestTimeToParty(shed):
    times = []
    for i in shed:
        times += [(i[0], 'start', i[-1])]
        times += [(i[1], 'end', i[-1])]

    sortlist(times)

    count, maxcount = 0, 0
    for i in times:
        if i[1] == 'start':
            count += i[-1]
            if count &gt; maxcount:
                maxcount = count
                time = i[0]
        else:
            count -= i[-1]
    print ('Best time to attend the party is at', time,\
           'o\'clock', ':', maxcount, 'values in total!')

profile.run('bestTimeToParty(sched3)')
</code></pre>
<p>ç»“æœå¦‚ä¸‹ï¼š</p>
<pre><code>Best time to attend the party is at 11.0 o'clock : 13 values in total!
         32 function calls in 0.013 seconds

   Ordered by: standard name

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.000    0.000    0.000    0.000 :0(exec)
        1    0.000    0.000    0.000    0.000 :0(print)
        1    0.012    0.012    0.012    0.012 :0(setprofile)
        1    0.000    0.000    0.000    0.000 :0(sort)
        1    0.000    0.000    0.000    0.000 &lt;string&gt;:1(&lt;module&gt;)
        1    0.000    0.000    0.000    0.000 ex3.py:12(sortlist)
       24    0.000    0.000    0.000    0.000 ex3.py:13(&lt;lambda&gt;)
        1    0.000    0.000    0.000    0.000 ex3.py:15(bestTimeToParty)
        1    0.000    0.000    0.013    0.013 profile:0(bestTimeToParty(sched3))
        0    0.000             0.000          profile:0(profiler)

</code></pre>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2023/03/05/big/" title="Misc-9-big from hackme.inndy.tw"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">Previous: Misc-9-big from hackme.inndy.tw</span></a><a class="button is-default" href="/2023/03/05/934/" title="LeetCode - 934. Shortest Bridge"><span class="has-text-weight-semibold">Next: LeetCode - 934. Shortest Bridge</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><div id="disqus_thread"></div><article class="mt-6 comment-container" id="disqus"><script>var disqus_config = function () {this.page.url = 'https://diamondi.github.io/2023/03/05/best-time-to-party/';this.page.identifier = 'https-diamondi-github-io';};</script><script>(function() {var d = document, s = d.createElement('script');s.src = 'https://https-diamondi-github-io.disqus.com/embed.js';s.setAttribute('data-timestamp', +new Date());(d.head || d.body).appendChild(s);})();</script><script id="dsq-count-scr" src="//blog-pubgj2togw.disqus.com/count.js" async></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/diamondi"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- çŸ¥ä¹--><!-- é¢†è‹±--><!-- è„¸ä¹¦--></section><p><span>Copyright Â©</span><span> DiamondI 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>